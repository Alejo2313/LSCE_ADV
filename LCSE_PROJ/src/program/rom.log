KCPSM6 Assembler log file for program 'D:\OneDrive\Documentos\Universidad\LCSE\entregas\LCSE_PROJ\src\program\rom.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 13 Nov 2020
Assembly timestamp: 14:51:22

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: F92 hex
Nominal program memory size: 4K (4096)   address(11:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 412
Memory locations available: 3684


Assembly listing

 Addr Code                     Instruction

 000                           ; LCSE picoblaze test program
 000                           ;Memory Map definition
 000                           CONSTANT sRAM, 10                  ; RAM Start address
 000                           CONSTANT eRAM, 1F                  ; RAM end address
 000                           CONSTANT DMA_MEM_BASE, C0          ;
 000                           CONSTANT DMA_CONF_CH1, C0          ;
 000                           CONSTANT DMA_SRC_CH1, C1           ;
 000                           CONSTANT DMA_DEST_CH1, C2          ;
 000                           CONSTANT DMA_CNT_CH1, C3           ;
 000                           CONSTANT DMA_CONF_CH2, C4          ;
 000                           CONSTANT DMA_SRC_CH2, C5           ;
 000                           CONSTANT DMA_DEST_CH2, C6          ;
 000                           CONSTANT DMA_CNT_CH2, C7           ;
 000                           CONSTANT DMA_CONF_CH3, C8          ;
 000                           CONSTANT DMA_SRC_CH3, C9           ;
 000                           CONSTANT DMA_DEST_CH3, CA          ;
 000                           CONSTANT DMA_CNT_CH3, CB           ;
 000                           CONSTANT RS232_BASE, D0            ;
 000                           CONSTANT RS232_CONF, D0            ;
 000                           CONSTANT RS232_STATUS, D1          ;
 000                           CONSTANT RS232_TX_DATA, D2         ;
 000                           CONSTANT RS232_RX_DAT, D3          ;
 000                           CONSTANT GPIO_BASE, E0             ;
 000                           CONSTANT GPIO_A, E0                ;
 000                           CONSTANT GPIO_MODEA_REG1, E1       ;
 000                           CONSTANT GPIO_MODEA_REG2, E2       ;
 000                           CONSTANT GPIO_AFMODEA_REG, E3      ;
 000                           CONSTANT GPIO_IRQA_MASK, E4        ;
 000                           CONSTANT GPIO_IRQMODEA_MASK, E5    ;
 000                           CONSTANT GPIO_B, E6                ;
 000                           CONSTANT GPIO_MODEB_REG1, E7       ;
 000                           CONSTANT GPIO_MODEB_REG2, E8       ;
 000                           CONSTANT GPIO_AFMODEB_REG, E9
 000                           CONSTANT GPIO_IRQB_MASK, EA        ;
 000                           CONSTANT GPIO_IRQMODEB_MASK, EB    ;
 000                           CONSTANT ISR_VECTOR, 00            ;
 000                           CONSTANT DMA_CH1_IRQ_MASK, 01
 000                           CONSTANT DMA_CH2_IRQ_MASK, 02
 000                           CONSTANT DMA_CH3_IRQ_MASK, 04
 000                           CONSTANT TX_IRQ_MASK, 10
 000                           CONSTANT RX_IRQ_MASK, 20
 000                           CONSTANT GPIOA_IRQ_MASK, 40
 000                           CONSTANT GPIOB_IRQ_MASK, 80
 000                           ; COMMADS -> ASCII to hex
 000                           CONSTANT ASCII_LF, 0A
 000                           CONSTANT ASCII_0, 30
 000                           CONSTANT ASCII_1, 31
 000                           CONSTANT ASCII_2, 32
 000                           CONSTANT ASCII_3, 33
 000                           CONSTANT ASCII_4, 34
 000                           CONSTANT ASCII_5, 35
 000                           CONSTANT ASCII_6, 36
 000                           CONSTANT ASCII_7, 37
 000                           CONSTANT ASCII_8, 38
 000                           CONSTANT ASCII_9, 39
 000                           CONSTANT ASCII_A, 41
 000                           CONSTANT ASCII_B, 42
 000                           CONSTANT ASCII_C, 43
 000                           CONSTANT ASCII_D, 44
 000                           CONSTANT ASCII_E, 45
 000                           CONSTANT ASCII_F, 46
 000                           CONSTANT ASCII_G, 47
 000                           CONSTANT ASCII_H, 48
 000                           CONSTANT ASCII_I, 49
 000                           CONSTANT ASCII_J, 4A
 000                           CONSTANT ASCII_K, 4B
 000                           CONSTANT ASCII_L, 4C
 000                           CONSTANT ASCII_M, 4D
 000                           CONSTANT ASCII_N, 4E
 000                           CONSTANT ASCII_O, 4F
 000                           CONSTANT ASCII_P, 50
 000                           CONSTANT ASCII_Q, 51
 000                           CONSTANT ASCII_R, 52
 000                           CONSTANT ASCII_S, 53
 000                           CONSTANT ASCII_T, 54
 000                           CONSTANT ASCII_U, 55
 000                           CONSTANT ASCII_V, 56
 000                           CONSTANT ASCII_W, 57
 000                           CONSTANT ASCII_X, 58
 000                           CONSTANT ASCII_Y, 59
 000                           CONSTANT ASCII_Z, 5A
 000                           STRING HEXAVAL$, "0123456789ABCDEF"
 000                           STRING SAYHELLOW$, "Hello World!"
 000                           STRING MERCADONA$, "Quiere bolsa?"
 000                           ; Static memory pointers
 000                           CONSTANT RX_STORE_CNT, 10
 000                           CONSTANT RX_STORE_BASE, 11
 000                           CONSTANT DMA_STR_BASE, 1A
 000                    start: 
 000  01000                    LOAD s0, 00
 001  2D010                    OUTPUT s0, 10[RX_STORE_CNT]
 002  2D011                    OUTPUT s0, 11[RX_STORE_BASE]
 003  01082                    LOAD s0, 82
 004  2D0D0                    OUTPUT s0, D0[RS232_CONF]
 005  0100C                    LOAD s0, 0C                        ;
 006  2D0E2                    OUTPUT s0, E2[GPIO_MODEA_REG2]
 007  01002                    LOAD s0, 02
 008  2D0E3                    OUTPUT s0, E3[GPIO_AFMODEA_REG]
 009  28001                    ENABLE INTERRUPT
 00A  2200A              loop: JUMP 00A[loop]
 00B              DMA_TX_TEST: 
 00B  01B0B                    LOAD sB, 0B[cajero'upper]
 00C  01AE6                    LOAD sA, E6[cajero'lower]
 00D  20C05                    CALL C05[DMA_TX_STR]
 00E  25000                    RETURN 
 00F                  RX_TEST: 
 00F  28001                    ENABLE INTERRUPT
 010  01120                    LOAD s1, 20[RX_IRQ_MASK]
 011  01000                    LOAD s0, 00
 012  2D010                    OUTPUT s0, 10[RX_STORE_CNT]
 013  2D011                    OUTPUT s0, 11[RX_STORE_BASE]
 014  01047                    LOAD s0, 47[ASCII_G]
 015  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 016  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 017  01700                    LOAD s7, 00
 018  01700                    LOAD s7, 00
 019  01043                    LOAD s0, 43[ASCII_C]
 01A  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 01B  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 01C  01700                    LOAD s7, 00
 01D  01700                    LOAD s7, 00
 01E  01041                    LOAD s0, 41[ASCII_A]
 01F  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 020  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 021  01700                    LOAD s7, 00
 022  01700                    LOAD s7, 00
 023  01035                    LOAD s0, 35
 024  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 025  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 026  01700                    LOAD s7, 00
 027  01700                    LOAD s7, 00
 028  01030                    LOAD s0, 30
 029  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 02A  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 02B  01700                    LOAD s7, 00
 02C  01700                    LOAD s7, 00
 02D  0100A                    LOAD s0, 0A[ASCII_LF]
 02E  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 02F  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 030  01700                    LOAD s7, 00
 031  01700                    LOAD s7, 00
 032  01047                    LOAD s0, 47[ASCII_G]
 033  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 034  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 035  01700                    LOAD s7, 00
 036  01700                    LOAD s7, 00
 037  01053                    LOAD s0, 53[ASCII_S]
 038  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 039  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 03A  01700                    LOAD s7, 00
 03B  01700                    LOAD s7, 00
 03C  01041                    LOAD s0, 41[ASCII_A]
 03D  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 03E  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 03F  01700                    LOAD s7, 00
 040  01700                    LOAD s7, 00
 041  01035                    LOAD s0, 35
 042  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 043  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 044  01700                    LOAD s7, 00
 045  01700                    LOAD s7, 00
 046  01030                    LOAD s0, 30
 047  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 048  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 049  01700                    LOAD s7, 00
 04A  01700                    LOAD s7, 00
 04B  0100A                    LOAD s0, 0A[ASCII_LF]
 04C  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 04D  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 04E  25000                    RETURN 
 04F             DEFAULT_TEST: 
 04F  010A1                    LOAD s0, A1
 050  01110                    LOAD s1, 10[sRAM]
 051  2C010                    OUTPUT s0, (s1)
 052  11101                    ADD s1, 01
 053  010A2                    LOAD s0, A2
 054  2C010                    OUTPUT s0, (s1)
 055  11101                    ADD s1, 01
 056  010A3                    LOAD s0, A3
 057  2C010                    OUTPUT s0, (s1)
 058  11101                    ADD s1, 01
 059  01055                    LOAD s0, 55                        ;
 05A  2D0E1                    OUTPUT s0, E1[GPIO_MODEA_REG1]
 05B  0105F                    LOAD s0, 5F                        ;
 05C  2D0E2                    OUTPUT s0, E2[GPIO_MODEA_REG2]
 05D  01002                    LOAD s0, 02
 05E  2D0E3                    OUTPUT s0, E3[GPIO_AFMODEA_REG]
 05F  010A0                    LOAD s0, A0
 060  2D0E7                    OUTPUT s0, E7[GPIO_MODEB_REG1]
 061  01080                    LOAD s0, 80
 062  2D0EB                    OUTPUT s0, EB[GPIO_IRQMODEB_MASK]
 063  2D0EA                    OUTPUT s0, EA[GPIO_IRQB_MASK]
 064  010FF                    LOAD s0, FF
 065  2D0E0                    OUTPUT s0, E0[GPIO_A]
 066  010D2                    LOAD s0, D2[RS232_TX_DATA]
 067  2D0C2                    OUTPUT s0, C2[DMA_DEST_CH1]
 068  01010                    LOAD s0, 10[sRAM]
 069  2D0C1                    OUTPUT s0, C1[DMA_SRC_CH1]
 06A  01012                    LOAD s0, 12
 06B  2D0C3                    OUTPUT s0, C3[DMA_CNT_CH1]
 06C  010A0                    LOAD s0, A0
 06D  2D0C0                    OUTPUT s0, C0[DMA_CONF_CH1]
 06E  09010                    INPUT s0, 10[sRAM]
 06F  2D0D2                    OUTPUT s0, D2[RS232_TX_DATA]
 070  010CF                    LOAD s0, CF
 071  2D0D0                    OUTPUT s0, D0[RS232_CONF]
 072  01800                    LOAD s8, 00
 073  2D800                    OUTPUT s8, 00[ISR_VECTOR]
 074  28001                    ENABLE INTERRUPT
 075  25000                    RETURN 
 076                 DELAY_MS: 
 076  2007A                    CALL 07A[DELAY_1MS]
 077  19001                    SUB s0, 01
 078  36076                    JUMP NZ, 076[DELAY_MS]
 079  25000                    RETURN 
 07A                DELAY_1MS: 
 07A  01800                    LOAD s8, 00
 07B  01900                    LOAD s9, 00
 07C           DELAY_1MS_LOOP: 
 07C  11808                    ADD s8, 08
 07D  13900                    ADDCY s9, 00
 07E  1D94E                    COMPARE s9, 4E
 07F  3A07C                    JUMP C, 07C[DELAY_1MS_LOOP]
 080  25000                    RETURN 
 081         DMA_CH1_CALLBACK: 
 081  25000                    RETURN 
 082         DMA_CH2_CALLBACK: 
 082  25000                    RETURN 
 083         DMA_CH3_CALLBACK: 
 083  25000                    RETURN 
 084           GPIOA_CALLBACK: 
 084  25000                    RETURN 
 085           GPIOB_CALLBACK: 
 085  25000                    RETURN 
 086              TX_CALLBACK: 
 086  25000                    RETURN 
 A80                           ADDRESS A80
 A80              RX_CALLBACK: 
 A80  099D3                    INPUT s9, D3[RS232_RX_DAT]         ;> Load RX data
 A81  1D90A                    COMPARE s9, 0A[ASCII_LF]           ;> Check end of line
 A82  32A8D                    JUMP Z, A8D[NEW_COMMAND]
 A83  09A10                    INPUT sA, 10[RX_STORE_CNT]         ;> Load mem counter
 A84  00BA0                    LOAD sB, sA
 A85  11B11                    ADD sB, 11[RX_STORE_BASE]          ;> Calc save address
 A86  2C9B0                    OUTPUT s9, (sB)                    ;> Store new value
 A87  11A01                    ADD sA, 01                         ;> Increment counter
 A88                           ; Avoid memory overflow
 A88  1DA06                    COMPARE sA, 06                     ;> Compare counter with max value
 A89  3AA8B                    JUMP C, A8B[RX_INBOUND]
 A8A  19A01                    SUB sA, 01                         ;> if greater, return to previus value
 A8B               RX_INBOUND: 
 A8B  2DA10                    OUTPUT sA, 10[RX_STORE_CNT]        ;> Store count value
 A8C  25000                    RETURN                             ;> Return
 A8D              NEW_COMMAND: 
 A8D                           ; Some sintax sugar
 A8D                           NAMEREG s7, tmp
 A8D                           NAMEREG s8, mode
 A8D                           NAMEREG s9, cmdDir
 A8D                           NAMEREG sA, cmd
 A8D                           NAMEREG sB, pinN
 A8D                           NAMEREG sC, modeMask
 A8D                           NAMEREG sD, pinMask
 A8D                           NAMEREG sE, ModeReg
 A8D                           NAMEREG sF, gpioPort
 A8D                           ; Get the first command character
 A8D  01911                    LOAD s9[cmdDir], 11[RX_STORE_BASE] ;> Store input value pointer
 A8E  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load first input value
 A8F  1DA47                    COMPARE sA[cmd], 47[ASCII_G]       ;> Look for GPIO command
 A90  32A96                    JUMP Z, A96[GPIO_CMD]
 A91  1DA54                    COMPARE sA[cmd], 54[ASCII_T]       ;> Look for TEMP command
 A92  32BCE                    JUMP Z, BCE[TEMP_CMD]
 A93  1DA52                    COMPARE sA[cmd], 52[ASCII_R]       ;> Look for REGISTER command
 A94  32BCF                    JUMP Z, BCF[REG_CMD]
 A95  22BD0                    JUMP BD0[CLC_CMD]                  ;> If no matching commad, clear registers
 A96                           ; When GPIO command
 A96                 GPIO_CMD: 
 A96  11902                    ADD s9[cmdDir], 02                 ;> Increment pointer
 A97  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Get port
 A98  01FE0                    LOAD sF[gpioPort], E0[GPIO_A]      ;> Load GPIOA as default
 A99  1DA41                    COMPARE sA[cmd], 41[ASCII_A]       ;> Check if GPIOA
 A9A  32A9C                    JUMP Z, A9C[GPIO_GET_PIN]          ;> If correct, continue
 A9B  01FE6                    LOAD sF[gpioPort], E6[GPIO_B]      ;> If no GPIOA, change to GPIOB
 A9C                           ; Calculate PIN and registers
 A9C             GPIO_GET_PIN: 
 A9C  11901                    ADD s9[cmdDir], 01                 ;> Increment pointer
 A9D  08B90                    INPUT sB[pinN], (s9[cmdDir])       ;> Load pin value
 A9E  19B30                    SUB sB[pinN], 30                   ;> Convert to ASCII to DEC
 A9F  3ABD0                    JUMP C, BD0[CLC_CMD]               ;> Check underflow. If true, the value is invalid so,
 AA0                           ;> go to clean registers. (FAIL)
 AA0  1DB08                    COMPARE sB[pinN], 08               ;> Check if pin below 8 (MAX PIN)
 AA1  3AAA3                    JUMP C, AA3[GPIO_CALC_MASK]        ;> if less than, continue
 AA2  22BD0                    JUMP BD0[CLC_CMD]                  ;> if greater/equal, the values is invalid (FAIL)
 AA3                           ; Calculate PIN MASK and MODE MASK
 AA3           GPIO_CALC_MASK: 
 AA3  01D01                    LOAD sD[pinMask], 01               ;> Set deault pin mask (PIN0)
 AA4  01C03                    LOAD sC[modeMask], 03              ;> Set default mode mask (INPUT)
 AA5  007B0                    LOAD s7[tmp], sB[pinN]             ;> Save pin value
 AA6           GPIO_MASK_LOOP: 
 AA6  1D700                    COMPARE s7[tmp], 00                ;> check pin counter equal 0
 AA7  32AAD                    JUMP Z, AAD[GPIO_CMD_SELECT]       ;> if true, continue
 AA8  14C02                    RL sC[modeMask]                    ;> Rotate left two positions mode mask
 AA9  14C02                    RL sC[modeMask]                    ;>
 AAA  14D02                    RL sD[pinMask]                     ;> Rotate left one position pin
 AAB  19701                    SUB s7[tmp], 01                    ;> Decrement pin counter
 AAC  22AA6                    JUMP AA6[GPIO_MASK_LOOP]
 AAD                           ; Check command type
 AAD          GPIO_CMD_SELECT: 
 AAD  01911                    LOAD s9[cmdDir], 11[RX_STORE_BASE] ;> Load base pointer
 AAE  11901                    ADD s9[cmdDir], 01                 ;> Increment pointer one position
 AAF  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Read command character
 AB0  1DA43                    COMPARE sA[cmd], 43[ASCII_C]       ;> Check configurarion command
 AB1  32AB7                    JUMP Z, AB7[GPIO_CONF_CMD]
 AB2  1DA53                    COMPARE sA[cmd], 53[ASCII_S]       ;> Check set command
 AB3  32BC5                    JUMP Z, BC5[GPIO_SET_CMD]
 AB4  1DA52                    COMPARE sA[cmd], 52[ASCII_R]       ;> Check reset command
 AB5  32BC9                    JUMP Z, BC9[GPIO_RESET_CMD]
 AB6  22BD0                    JUMP BD0[CLC_CMD]
 AB7                           ; When configuration command
 AB7            GPIO_CONF_CMD: 
 AB7  11903                    ADD s9[cmdDir], 03                 ;> Increment pointer one position
 AB8  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Read command character
 AB9  01E02                    LOAD sE[ModeReg], 02               ;> Load modeReg2 offsert
 ABA  1DB04                    COMPARE sB[pinN], 04               ;> Check if offset is correct
 ABB  3AABD                    JUMP C, ABD[GPIO_CONTINUE]
 ABC  01E01                    LOAD sE[ModeReg], 01               ;> Load modeReg1 offset
 ABD            GPIO_CONTINUE: 
 ABD  10EF0                    ADD sE[ModeReg], sF[gpioPort]      ;> Calc modereg address
 ABE  1DA30                    COMPARE sA[cmd], 30[ASCII_0]       ;> Configure mode output
 ABF  32ACB                    JUMP Z, ACB[GPIO_CONF_OUT]
 AC0  1DA31                    COMPARE sA[cmd], 31[ASCII_1]       ;> Configure mode intput
 AC1  32B80                    JUMP Z, B80[GPIO_CONF_IN]
 AC2  1DA32                    COMPARE sA[cmd], 32[ASCII_2]       ;> Configure mode input irq rissing
 AC3  32B89                    JUMP Z, B89[GPIO_CONF_OR]
 AC4  1DA33                    COMPARE sA[cmd], 33[ASCII_3]       ;> Configure mode input irq falling
 AC5  32B9A                    JUMP Z, B9A[GPIO_CONF_OF]
 AC6  1DA34                    COMPARE sA[cmd], 34[ASCII_4]       ;> Configure mode AF input
 AC7  32BAA                    JUMP Z, BAA[GPIO_CONF_AFI]
 AC8  1DA35                    COMPARE sA[cmd], 35[ASCII_5]       ;> Configure AF outpur
 AC9  32BB4                    JUMP Z, BB4[GPIO_CONF_AFO]
 ACA  22BD0                    JUMP BD0[CLC_CMD]
 ACB            GPIO_CONF_OUT: 
 ACB  01855                    LOAD s8[mode], 55                  ;> Load mode mask (all pin on)
 ACC  22BBD                    JUMP BBD[GPIO_CONF_PIN]            ;> Configure
 B80                           ADDRESS B80
 B80             GPIO_CONF_IN: 
 B80  018AA                    LOAD s8[mode], AA                  ;> Load mode mask (all pin on)
 B81  009F0                    LOAD s9[cmdDir], sF[gpioPort]      ;> Load GPIO port
 B82  11904                    ADD s9[cmdDir], 04                 ;> Calc IRQ reg address
 B83  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load IRQ reg value
 B84  07DFF                    XOR sD[pinMask], FF                ;> No pinMask value
 B85  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clean current conf
 B86  07DFF                    XOR sD[pinMask], FF                ;> Restore pinMask
 B87  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> Save register
 B88  22BBD                    JUMP BBD[GPIO_CONF_PIN]            ;> Configure
 B89             GPIO_CONF_OR: 
 B89  018AA                    LOAD s8[mode], AA                  ;> Load mode mask (all pin on)
 B8A  009F0                    LOAD s9[cmdDir], sF[gpioPort]      ;> Load GPIO port
 B8B  11904                    ADD s9[cmdDir], 04                 ;> Calc IRQ reg address
 B8C  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load IRQ reg value
 B8D  07DFF                    XOR sD[pinMask], FF                ;> No pinMask value
 B8E  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clean current conf
 B8F  07DFF                    XOR sD[pinMask], FF                ;> Restore pinMask
 B90  04AD0                    OR sA[cmd], sD[pinMask]            ;> Set IRQ enable
 B91  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> Save register
 B92  11901                    ADD s9[cmdDir], 01                 ;> Calc IRQ mode register
 B93  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load IRQ mode value
 B94  07DFF                    XOR sD[pinMask], FF                ;> Not pin mask value
 B95  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clean current conf
 B96  07DFF                    XOR sD[pinMask], FF                ;> Restore pinMask
 B97  04AD0                    OR sA[cmd], sD[pinMask]            ;> Set IRQ enable
 B98  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> Save register
 B99  22BBD                    JUMP BBD[GPIO_CONF_PIN]
 B9A             GPIO_CONF_OF: 
 B9A  018AA                    LOAD s8[mode], AA                  ;> Load mode mask (all pin on)
 B9B  009F0                    LOAD s9[cmdDir], sF[gpioPort]      ;> Load GPIO port
 B9C  11904                    ADD s9[cmdDir], 04                 ;> Calc IRQ reg address
 B9D  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load IRQ reg value
 B9E  07DFF                    XOR sD[pinMask], FF                ;> No pinMask value
 B9F  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clean current conf
 BA0  07DFF                    XOR sD[pinMask], FF                ;> Restore pinMask
 BA1  04AD0                    OR sA[cmd], sD[pinMask]            ;> Set IRQ enable
 BA2  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> Save register
 BA3  11901                    ADD s9[cmdDir], 01                 ;> Calc IRQ mode register
 BA4  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load IRQ mode value
 BA5  07DFF                    XOR sD[pinMask], FF                ;> Not pin mask value
 BA6  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clean current conf
 BA7  07DFF                    XOR sD[pinMask], FF                ;> Restore pinMask
 BA8  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> Save register
 BA9  22BBD                    JUMP BBD[GPIO_CONF_PIN]
 BAA            GPIO_CONF_AFI: 
 BAA  018FF                    LOAD s8[mode], FF                  ;> Load mode mask (all pin on)
 BAB  009F0                    LOAD s9[cmdDir], sF[gpioPort]      ;> Load GPIO port
 BAC  11903                    ADD s9[cmdDir], 03                 ;> Calc AF mode address
 BAD  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Get AF mode vlaue
 BAE  07DFF                    XOR sD[pinMask], FF                ;> Not pinmask
 BAF  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clear current value
 BB0  07DFF                    XOR sD[pinMask], FF                ;> restore pin mask
 BB1  04AD0                    OR sA[cmd], sD[pinMask]            ;> Set mode
 BB2  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> save value
 BB3  22BBD                    JUMP BBD[GPIO_CONF_PIN]
 BB4            GPIO_CONF_AFO: 
 BB4  018FF                    LOAD s8[mode], FF                  ;> Load mode mask (all pin on)
 BB5  009F0                    LOAD s9[cmdDir], sF[gpioPort]      ;> Load GPIO port
 BB6  11903                    ADD s9[cmdDir], 03                 ;> Calc AF mode address
 BB7  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Get AF mode vlaue
 BB8  07DFF                    XOR sD[pinMask], FF                ;> Not pinmask
 BB9  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clear current value
 BBA  07DFF                    XOR sD[pinMask], FF                ;> restore pin mask
 BBB  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> save value
 BBC  22BBD                    JUMP BBD[GPIO_CONF_PIN]
 BBD            GPIO_CONF_PIN: 
 BBD  08AE0                    INPUT sA[cmd], (sE[ModeReg])       ;> Get current mode reg
 BBE  07CFF                    XOR sC[modeMask], FF               ;> Not mode mask
 BBF  02AC0                    AND sA[cmd], sC[modeMask]          ;> Clean current value
 BC0  07CFF                    XOR sC[modeMask], FF               ;> Restore pinMask
 BC1  028C0                    AND s8[mode], sC[modeMask]         ;> set pin mode (only selected pin)
 BC2  04A80                    OR sA[cmd], s8[mode]               ;> Update mode reg
 BC3  2CAE0                    OUTPUT sA[cmd], (sE[ModeReg])      ;> Set mode reg
 BC4  22BD0                    JUMP BD0[CLC_CMD]                  ;> Clean data
 BC5             GPIO_SET_CMD: 
 BC5  08AF0                    INPUT sA[cmd], (sF[gpioPort])      ;> Get current GPIO reg
 BC6  04AD0                    OR sA[cmd], sD[pinMask]            ;> Update GPIO reg
 BC7  2CAF0                    OUTPUT sA[cmd], (sF[gpioPort])     ;> set new GPIO reg
 BC8  22BD0                    JUMP BD0[CLC_CMD]                  ;> Clean data
 BC9           GPIO_RESET_CMD: 
 BC9  08AF0                    INPUT sA[cmd], (sF[gpioPort])      ;> Get current GPIO reg
 BCA  07DFF                    XOR sD[pinMask], FF                ;> Update GPIO reg. (NOT is not implemented so, we use XOR)
 BCB  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clean bit
 BCC  2CAF0                    OUTPUT sA[cmd], (sF[gpioPort])     ;> Set new GPIO reg
 BCD  22BD0                    JUMP BD0[CLC_CMD]                  ;> Clean data
 BCE                 TEMP_CMD: 
 BCE  22BD0                    JUMP BD0[CLC_CMD]                  ;> Clean data
 BCF                  REG_CMD: 
 BCF  22BD0                    JUMP BD0[CLC_CMD]                  ;> Clean data
 BD0                           ; Clean
 BD0                  CLC_CMD: 
 BD0                           ; Restore register names
 BD0                           NAMEREG tmp, s7
 BD0                           NAMEREG mode, s8
 BD0                           NAMEREG cmdDir, s9
 BD0                           NAMEREG cmd, sA
 BD0                           NAMEREG pinN, sB
 BD0                           NAMEREG modeMask, sC
 BD0                           NAMEREG pinMask, sD
 BD0                           NAMEREG ModeReg, sE
 BD0                           NAMEREG gpioPort, sF
 BD0  09B10                    INPUT sB, 10[RX_STORE_CNT]         ;> Get counter
 BD1  01C00                    LOAD sC, 00                        ;> Set 0 value
 BD2  2DC10                    OUTPUT sC, 10[RX_STORE_CNT]
 BD3             LOOP_CMD_CLC: 
 BD3  01A11                    LOAD sA, 11[RX_STORE_BASE]         ;> Load base register
 BD4  10AB0                    ADD sA, sB                         ;> Set address
 BD5  2CCA0                    OUTPUT sC, (sA)                    ;> Clean register
 BD6  19B01                    SUB sB, 01                         ;> decrement counter
 BD7  36BD3                    JUMP NZ, BD3[LOOP_CMD_CLC]         ;> While not 0
 BD8  25000                    RETURN 
 BD9  21148            hellow: LOAD&RETURN s1, 48[SAYHELLOW$:"H"]
 BDA  21165                    LOAD&RETURN s1, 65[SAYHELLOW$:"e"]
 BDB  2116C                    LOAD&RETURN s1, 6C[SAYHELLOW$:"l"]
 BDC  2116C                    LOAD&RETURN s1, 6C[SAYHELLOW$:"l"]
 BDD  2116F                    LOAD&RETURN s1, 6F[SAYHELLOW$:"o"]
 BDE  21120                    LOAD&RETURN s1, 20[SAYHELLOW$:" "]
 BDF  21157                    LOAD&RETURN s1, 57[SAYHELLOW$:"W"]
 BE0  2116F                    LOAD&RETURN s1, 6F[SAYHELLOW$:"o"]
 BE1  21172                    LOAD&RETURN s1, 72[SAYHELLOW$:"r"]
 BE2  2116C                    LOAD&RETURN s1, 6C[SAYHELLOW$:"l"]
 BE3  21164                    LOAD&RETURN s1, 64[SAYHELLOW$:"d"]
 BE4  21121                    LOAD&RETURN s1, 21[SAYHELLOW$:"!"]
 BE5  2110A                    LOAD&RETURN s1, 0A[ASCII_LF]
 BE6  21151            cajero: LOAD&RETURN s1, 51[MERCADONA$:"Q"]
 BE7  21175                    LOAD&RETURN s1, 75[MERCADONA$:"u"]
 BE8  21169                    LOAD&RETURN s1, 69[MERCADONA$:"i"]
 BE9  21165                    LOAD&RETURN s1, 65[MERCADONA$:"e"]
 BEA  21172                    LOAD&RETURN s1, 72[MERCADONA$:"r"]
 BEB  21165                    LOAD&RETURN s1, 65[MERCADONA$:"e"]
 BEC  21120                    LOAD&RETURN s1, 20[MERCADONA$:" "]
 BED  21162                    LOAD&RETURN s1, 62[MERCADONA$:"b"]
 BEE  2116F                    LOAD&RETURN s1, 6F[MERCADONA$:"o"]
 BEF  2116C                    LOAD&RETURN s1, 6C[MERCADONA$:"l"]
 BF0  21173                    LOAD&RETURN s1, 73[MERCADONA$:"s"]
 BF1  21161                    LOAD&RETURN s1, 61[MERCADONA$:"a"]
 BF2  2113F                    LOAD&RETURN s1, 3F[MERCADONA$:"?"]
 BF3  2110A                    LOAD&RETURN s1, 0A[ASCII_LF]
 BF4  21130              hexv: LOAD&RETURN s1, 30[HEXAVAL$:"0"]
 BF5  21131                    LOAD&RETURN s1, 31[HEXAVAL$:"1"]
 BF6  21132                    LOAD&RETURN s1, 32[HEXAVAL$:"2"]
 BF7  21133                    LOAD&RETURN s1, 33[HEXAVAL$:"3"]
 BF8  21134                    LOAD&RETURN s1, 34[HEXAVAL$:"4"]
 BF9  21135                    LOAD&RETURN s1, 35[HEXAVAL$:"5"]
 BFA  21136                    LOAD&RETURN s1, 36[HEXAVAL$:"6"]
 BFB  21137                    LOAD&RETURN s1, 37[HEXAVAL$:"7"]
 BFC  21138                    LOAD&RETURN s1, 38[HEXAVAL$:"8"]
 BFD  21139                    LOAD&RETURN s1, 39[HEXAVAL$:"9"]
 BFE  21141                    LOAD&RETURN s1, 41[HEXAVAL$:"A"]
 BFF  21142                    LOAD&RETURN s1, 42[HEXAVAL$:"B"]
 C00  21143                    LOAD&RETURN s1, 43[HEXAVAL$:"C"]
 C01  21144                    LOAD&RETURN s1, 44[HEXAVAL$:"D"]
 C02  21145                    LOAD&RETURN s1, 45[HEXAVAL$:"E"]
 C03  21146                    LOAD&RETURN s1, 46[HEXAVAL$:"F"]
 C04  2110D                    LOAD&RETURN s1, 0D
 C05                           ;LOAD sA and sB with the string load address
 C05               DMA_TX_STR: 
 C05  01000                    LOAD s0, 00
 C06  0121A                    LOAD s2, 1A[DMA_STR_BASE]
 C07          DMA_TX_STR_LOOP: 
 C07  24BA0                    CALL@ (sB, sA)
 C08  0121A                    LOAD s2, 1A[DMA_STR_BASE]
 C09  10200                    ADD s2, s0
 C0A  2C120                    OUTPUT s1, (s2)
 C0B  1D10A                    COMPARE s1, 0A[ASCII_LF]
 C0C  32C11                    JUMP Z, C11[DMA_TX_LOAD]
 C0D  11001                    ADD s0, 01
 C0E  11A01                    ADD sA, 01
 C0F  13B00                    ADDCY sB, 00
 C10  22C07                    JUMP C07[DMA_TX_STR_LOOP]
 C11              DMA_TX_LOAD: 
 C11  011D2                    LOAD s1, D2[RS232_TX_DATA]
 C12  2D1C2                    OUTPUT s1, C2[DMA_DEST_CH1]
 C13  0111A                    LOAD s1, 1A[DMA_STR_BASE]
 C14  2D1C1                    OUTPUT s1, C1[DMA_SRC_CH1]
 C15  0300F                    AND s0, 0F
 C16  05010                    OR s0, 10
 C17  2D0C3                    OUTPUT s0, C3[DMA_CNT_CH1]
 C18  010A0                    LOAD s0, A0
 C19  2D0C0                    OUTPUT s0, C0[DMA_CONF_CH1]
 C1A  0901A                    INPUT s0, 1A[DMA_STR_BASE]
 C1B  2D0D2                    OUTPUT s0, D2[RS232_TX_DATA]
 C1C  010CF                    LOAD s0, CF
 C1D  2D0D0                    OUTPUT s0, D0[RS232_CONF]
 C1E  25000                    RETURN 
 C1F                  HEX2DEC: 
 C1F  01B0B                    LOAD sB, 0B[hexv'upper]
 C20  01AF4                    LOAD sA, F4[hexv'lower]
 C21  01F00                    LOAD sF, 00
 C22                   HEXCMP: 
 C22  24BA0                    CALL@ (sB, sA)
 C23  1C100                    COMPARE s1, s0
 C24  32C2B                    JUMP Z, C2B[HEXVAL_RETURN]
 C25  11A01                    ADD sA, 01
 C26  13B00                    ADDCY sB, 00
 C27  11F01                    ADD sF, 01
 C28  1D1D0                    COMPARE s1, D0
 C29  32C2B                    JUMP Z, C2B[HEXVAL_RETURN]
 C2A  22C22                    JUMP C22[HEXCMP]
 C2B            HEXVAL_RETURN: 
 C2B  25000                    RETURN 
 C2C                  DEC2HEX: 
 C2C  01B0B                    LOAD sB, 0B[hexv'upper]
 C2D  01AF4                    LOAD sA, F4[hexv'lower]
 C2E  1D010                    COMPARE s0, 10
 C2F  3AC31                    JUMP C, C31[DEC2HEX_C]
 C30  25000                    RETURN 
 C31                DEC2HEX_C: 
 C31  10A00                    ADD sA, s0
 C32  13B00                    ADDCY sB, 00
 C33  24BA0                    CALL@ (sB, sA)
 C34  25000                    RETURN 
 F80                           ADDRESS F80
 F80                      ISR: 
 F80  28000                    DISABLE INTERRUPT
 F81  09800                    INPUT s8, 00[ISR_VECTOR]           ;Read ISR vector
 F82                           ; Check DMA IRQ
 F82  0D801                    TEST s8, 01[DMA_CH1_IRQ_MASK]      ;DMA Channel 1
 F83  34081                    CALL NZ, 081[DMA_CH1_CALLBACK]
 F84  0D802                    TEST s8, 02[DMA_CH2_IRQ_MASK]      ;DMA Channel 2
 F85  34082                    CALL NZ, 082[DMA_CH2_CALLBACK]
 F86  0D804                    TEST s8, 04[DMA_CH3_IRQ_MASK]      ;DMA Channel 3
 F87  34083                    CALL NZ, 083[DMA_CH3_CALLBACK]
 F88                           ; Check GPIO IRQ
 F88  0D840                    TEST s8, 40[GPIOA_IRQ_MASK]        ;GPIOA
 F89  34084                    CALL NZ, 084[GPIOA_CALLBACK]
 F8A  0D840                    TEST s8, 40[GPIOA_IRQ_MASK]        ;GPIOB
 F8B  34084                    CALL NZ, 084[GPIOA_CALLBACK]
 F8C                           ; Check RS232 IRQ
 F8C  0D810                    TEST s8, 10[TX_IRQ_MASK]           ;RS232 TX
 F8D  34086                    CALL NZ, 086[TX_CALLBACK]
 F8E  0D820                    TEST s8, 20[RX_IRQ_MASK]           ;RS232 RX
 F8F  34A80                    CALL NZ, A80[RX_CALLBACK]
 F90  01800                    LOAD s8, 00
 F91  2D800                    OUTPUT s8, 00[ISR_VECTOR]          ;Clean vector
 F92  29001                    RETURNI ENABLE


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

D:\OneDrive\Documentos\Universidad\LCSE\entregas\LCSE_PROJ\src\program\rom.psm



List of defined constants

 CONSTANT name      Value        Source PSM File

 timestamp_hours    14'd         
 timestamp_minutes  51'd         
 timestamp_seconds  22'd         
 datestamp_year     20'd         
 datestamp_month    11'd         
 datestamp_day      13'd         
 NUL                00           
 BEL                07           
 BS                 08           
 HT                 09           
 LF                 0A           
 VT                 0B           
 CR                 0D           
 ESC                1B           
 DEL                7F           
 DCS                90           
 ST                 9C           
 sRAM               10           rom.psm
 eRAM               1F           rom.psm
 DMA_MEM_BASE       C0           rom.psm
 DMA_CONF_CH1       C0           rom.psm
 DMA_SRC_CH1        C1           rom.psm
 DMA_DEST_CH1       C2           rom.psm
 DMA_CNT_CH1        C3           rom.psm
 DMA_CONF_CH2       C4           rom.psm
 DMA_SRC_CH2        C5           rom.psm
 DMA_DEST_CH2       C6           rom.psm
 DMA_CNT_CH2        C7           rom.psm
 DMA_CONF_CH3       C8           rom.psm
 DMA_SRC_CH3        C9           rom.psm
 DMA_DEST_CH3       CA           rom.psm
 DMA_CNT_CH3        CB           rom.psm
 RS232_BASE         D0           rom.psm
 RS232_CONF         D0           rom.psm
 RS232_STATUS       D1           rom.psm
 RS232_TX_DATA      D2           rom.psm
 RS232_RX_DAT       D3           rom.psm
 GPIO_BASE          E0           rom.psm
 GPIO_A             E0           rom.psm
 GPIO_MODEA_REG1    E1           rom.psm
 GPIO_MODEA_REG2    E2           rom.psm
 GPIO_AFMODEA_REG   E3           rom.psm
 GPIO_IRQA_MASK     E4           rom.psm
 GPIO_IRQMODEA_MASK E5           rom.psm
 GPIO_B             E6           rom.psm
 GPIO_MODEB_REG1    E7           rom.psm
 GPIO_MODEB_REG2    E8           rom.psm
 GPIO_AFMODEB_REG   E9           rom.psm
 GPIO_IRQB_MASK     EA           rom.psm
 GPIO_IRQMODEB_MASK EB           rom.psm
 ISR_VECTOR         00           rom.psm
 DMA_CH1_IRQ_MASK   01           rom.psm
 DMA_CH2_IRQ_MASK   02           rom.psm
 DMA_CH3_IRQ_MASK   04           rom.psm
 TX_IRQ_MASK        10           rom.psm
 RX_IRQ_MASK        20           rom.psm
 GPIOA_IRQ_MASK     40           rom.psm
 GPIOB_IRQ_MASK     80           rom.psm
 ASCII_LF           0A           rom.psm
 ASCII_0            30           rom.psm
 ASCII_1            31           rom.psm
 ASCII_2            32           rom.psm
 ASCII_3            33           rom.psm
 ASCII_4            34           rom.psm
 ASCII_5            35           rom.psm
 ASCII_6            36           rom.psm
 ASCII_7            37           rom.psm
 ASCII_8            38           rom.psm
 ASCII_9            39           rom.psm
 ASCII_A            41           rom.psm
 ASCII_B            42           rom.psm
 ASCII_C            43           rom.psm
 ASCII_D            44           rom.psm
 ASCII_E            45           rom.psm
 ASCII_F            46           rom.psm
 ASCII_G            47           rom.psm
 ASCII_H            48           rom.psm
 ASCII_I            49           rom.psm
 ASCII_J            4A           rom.psm
 ASCII_K            4B           rom.psm
 ASCII_L            4C           rom.psm
 ASCII_M            4D           rom.psm
 ASCII_N            4E           rom.psm
 ASCII_O            4F           rom.psm
 ASCII_P            50           rom.psm
 ASCII_Q            51           rom.psm
 ASCII_R            52           rom.psm
 ASCII_S            53           rom.psm
 ASCII_T            54           rom.psm
 ASCII_U            55           rom.psm
 ASCII_V            56           rom.psm
 ASCII_W            57           rom.psm
 ASCII_X            58           rom.psm
 ASCII_Y            59           rom.psm
 ASCII_Z            5A           rom.psm
 RX_STORE_CNT       10           rom.psm
 RX_STORE_BASE      11           rom.psm
 DMA_STR_BASE       1A           rom.psm



No TABLEs defined



List of text strings

 STRING name       String              Source PSM File

 KCPSM6_version$   "v2.70"             
 datestamp$        "13 Nov 2020"       
 timestamp$        "14:51:22"          
 HEXAVAL$          "0123456789ABCDEF"  rom.psm
 SAYHELLOW$        "Hello World!"      rom.psm
 MERCADONA$        "Quiere bolsa?"     rom.psm



List of line labels

   Label              Addr  Source PSM File

 * start              000   rom.psm
   loop               00A   rom.psm
 * DMA_TX_TEST        00B   rom.psm
 * RX_TEST            00F   rom.psm
 * DEFAULT_TEST       04F   rom.psm
   DELAY_MS           076   rom.psm
   DELAY_1MS          07A   rom.psm
   DELAY_1MS_LOOP     07C   rom.psm
   DMA_CH1_CALLBACK   081   rom.psm
   DMA_CH2_CALLBACK   082   rom.psm
   DMA_CH3_CALLBACK   083   rom.psm
   GPIOA_CALLBACK     084   rom.psm
 * GPIOB_CALLBACK     085   rom.psm
   TX_CALLBACK        086   rom.psm
   RX_CALLBACK        A80   rom.psm
   RX_INBOUND         A8B   rom.psm
   NEW_COMMAND        A8D   rom.psm
   GPIO_CMD           A96   rom.psm
   GPIO_GET_PIN       A9C   rom.psm
   GPIO_CALC_MASK     AA3   rom.psm
   GPIO_MASK_LOOP     AA6   rom.psm
   GPIO_CMD_SELECT    AAD   rom.psm
   GPIO_CONF_CMD      AB7   rom.psm
   GPIO_CONTINUE      ABD   rom.psm
   GPIO_CONF_OUT      ACB   rom.psm
   GPIO_CONF_IN       B80   rom.psm
   GPIO_CONF_OR       B89   rom.psm
   GPIO_CONF_OF       B9A   rom.psm
   GPIO_CONF_AFI      BAA   rom.psm
   GPIO_CONF_AFO      BB4   rom.psm
   GPIO_CONF_PIN      BBD   rom.psm
   GPIO_SET_CMD       BC5   rom.psm
   GPIO_RESET_CMD     BC9   rom.psm
   TEMP_CMD           BCE   rom.psm
   REG_CMD            BCF   rom.psm
   CLC_CMD            BD0   rom.psm
   LOOP_CMD_CLC       BD3   rom.psm
 * hellow             BD9   rom.psm
   cajero             BE6   rom.psm
   hexv               BF4   rom.psm
   DMA_TX_STR         C05   rom.psm
   DMA_TX_STR_LOOP    C07   rom.psm
   DMA_TX_LOAD        C11   rom.psm
 * HEX2DEC            C1F   rom.psm
   HEXCMP             C22   rom.psm
   HEXVAL_RETURN      C2B   rom.psm
   DEC2HEX            C2C   rom.psm
   DEC2HEX_C          C31   rom.psm
 * ISR                F80   rom.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             96
 STAR              -

 AND              11
 OR                7
 XOR              17

 ADD              25
 ADDCY             4
 SUB               5
 SUBCY             -

 TEST              7
 TESTCY            -
 COMPARE          23
 COMPARECY         -

 SL0               -
 SL1               -
 SLX               -
 SLA               -
 RL                3
 SR0               -
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT            21
 OUTPUT           70
 OUTPUTK           -

 STORE             -
 FETCH             -

 DISABLE           1
 ENABLE            3
 RETURNI           1

 JUMP             45
 JUMP@             -
 CALL              9
 CALL@             3
 RETURN           17
 LOAD&RETURN      44

 HWBUILD           -



End of KCPSM6 log file.

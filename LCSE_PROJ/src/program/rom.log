KCPSM6 Assembler log file for program 'D:\OneDrive\Documentos\Universidad\LCSE\entregas\LCSE_PROJ\src\program\rom.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 21 Nov 2020
Assembly timestamp: 13:01:21

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: F93 hex
Nominal program memory size: 4K (4096)   address(11:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 509
Memory locations available: 3587


Assembly listing

 Addr Code                     Instruction

 000                           ;       ...::: LCSE picoblaze test program :::...
 000                           ;
 000                           ;                               _____________
 000                           ;              /\      /\     /             \
 000                           ;             //\\____//\\   |   MAUUUU!!    |
 000                           ;            /     '      \   \  ___________/
 000                           ;           /   /\ '  /\    \ /_/
 000                           ;          |    == o ==     |        /|
 000                           ;           \      '        /       | |
 000                           ;             \           /         \ \
 000                           ;             /****<o>**** \         / /
 000                           ;             |            ' \       \ \
 000                           ;             |    |    | '   '\      \ \
 000                           ;  _________  | ´´ |  ' |     '  \    / /
 000                           ;  |  MAYA  | |  ' |    | '       |__/ /
 000                           ;   \______/   \__/ \__/ \_______/____/
 000                           ;               ..::: AGM&LFV 2020 :::..
 000                           ;       https://github.com/Alejo2313/LSCE_ADV
 000                           ;Memory Map definition
 000                           CONSTANT sRAM, 10                  ; RAM Start address
 000                           CONSTANT eRAM, 1F                  ; RAM end address
 000                           CONSTANT DMA_MEM_BASE, C0          ;
 000                           CONSTANT DMA_CONF_CH1, C0          ;
 000                           CONSTANT DMA_SRC_CH1, C1           ;
 000                           CONSTANT DMA_DEST_CH1, C2          ;
 000                           CONSTANT DMA_CNT_CH1, C3           ;
 000                           CONSTANT DMA_CONF_CH2, C4          ;
 000                           CONSTANT DMA_SRC_CH2, C5           ;
 000                           CONSTANT DMA_DEST_CH2, C6          ;
 000                           CONSTANT DMA_CNT_CH2, C7           ;
 000                           CONSTANT DMA_CONF_CH3, C8          ;
 000                           CONSTANT DMA_SRC_CH3, C9           ;
 000                           CONSTANT DMA_DEST_CH3, CA          ;
 000                           CONSTANT DMA_CNT_CH3, CB           ;
 000                           CONSTANT RS232_BASE, D0            ;
 000                           CONSTANT RS232_CONF, D0            ;
 000                           CONSTANT RS232_STATUS, D1          ;
 000                           CONSTANT RS232_TX_DATA, D2         ;
 000                           CONSTANT RS232_RX_DAT, D3          ;
 000                           CONSTANT GPIO_BASE, E0             ;
 000                           CONSTANT GPIO_A, E0                ;
 000                           CONSTANT GPIO_MODEA_REG1, E1       ;
 000                           CONSTANT GPIO_MODEA_REG2, E2       ;
 000                           CONSTANT GPIO_AFMODEA_REG, E3      ;
 000                           CONSTANT GPIO_IRQA_MASK, E4        ;
 000                           CONSTANT GPIO_IRQMODEA_MASK, E5    ;
 000                           CONSTANT GPIO_B, E6                ;
 000                           CONSTANT GPIO_MODEB_REG1, E7       ;
 000                           CONSTANT GPIO_MODEB_REG2, E8       ;
 000                           CONSTANT GPIO_AFMODEB_REG, E9
 000                           CONSTANT GPIO_IRQB_MASK, EA        ;
 000                           CONSTANT GPIO_IRQMODEB_MASK, EB    ;
 000                           CONSTANT DISPLAY_EN, D8            ;
 000                           CONSTANT DISPLAY_IEN, D9           ;
 000                           CONSTANT DISPLAY_01, DA            ;
 000                           CONSTANT DISPLAY_23, DB            ;
 000                           CONSTANT DISPLAY_45, DC            ;
 000                           CONSTANT DISPLAY_67, DD            ;
 000                           CONSTANT ISR_VECTOR, 00            ;
 000                           CONSTANT DMA_CH1_IRQ_MASK, 01
 000                           CONSTANT DMA_CH2_IRQ_MASK, 02
 000                           CONSTANT DMA_CH3_IRQ_MASK, 04
 000                           CONSTANT TX_IRQ_MASK, 10
 000                           CONSTANT RX_IRQ_MASK, 20
 000                           CONSTANT GPIOA_IRQ_MASK, 40
 000                           CONSTANT GPIOB_IRQ_MASK, 80
 000                           ; COMMADS -> ASCII to hex
 000                           CONSTANT ASCII_LF, 0A
 000                           CONSTANT ASCII_0, 30
 000                           CONSTANT ASCII_1, 31
 000                           CONSTANT ASCII_2, 32
 000                           CONSTANT ASCII_3, 33
 000                           CONSTANT ASCII_4, 34
 000                           CONSTANT ASCII_5, 35
 000                           CONSTANT ASCII_6, 36
 000                           CONSTANT ASCII_7, 37
 000                           CONSTANT ASCII_8, 38
 000                           CONSTANT ASCII_9, 39
 000                           CONSTANT ASCII_A, 41
 000                           CONSTANT ASCII_B, 42
 000                           CONSTANT ASCII_C, 43
 000                           CONSTANT ASCII_D, 44
 000                           CONSTANT ASCII_E, 45
 000                           CONSTANT ASCII_F, 46
 000                           CONSTANT ASCII_G, 47
 000                           CONSTANT ASCII_H, 48
 000                           CONSTANT ASCII_I, 49
 000                           CONSTANT ASCII_J, 4A
 000                           CONSTANT ASCII_K, 4B
 000                           CONSTANT ASCII_L, 4C
 000                           CONSTANT ASCII_M, 4D
 000                           CONSTANT ASCII_N, 4E
 000                           CONSTANT ASCII_O, 4F
 000                           CONSTANT ASCII_P, 50
 000                           CONSTANT ASCII_Q, 51
 000                           CONSTANT ASCII_R, 52
 000                           CONSTANT ASCII_S, 53
 000                           CONSTANT ASCII_T, 54
 000                           CONSTANT ASCII_U, 55
 000                           CONSTANT ASCII_V, 56
 000                           CONSTANT ASCII_W, 57
 000                           CONSTANT ASCII_X, 58
 000                           CONSTANT ASCII_Y, 59
 000                           CONSTANT ASCII_Z, 5A
 000                           STRING HEXAVAL$, "0123456789ABCDEF"
 000                           STRING SAYHELLOW$, "Hello World!"
 000                           STRING MERCADONA$, "Quiere bolsa?"
 000                           STRING NACK$, "ERROR!!"
 000                           STRING ACK$, "OK!"
 000                           STRING PENE$, "Quiere bolsa?"
 000                           ; Static memory pointers
 000                           CONSTANT RX_STORE_CNT, 20
 000                           CONSTANT RX_STORE_BASE, 22
 000                           CONSTANT DMA_STR_BASE, 1A
 000                    start: 
 000  20013                    CALL 013[main_task]
 001  22001              loop: JUMP 001[loop]
 002                gpio_test: 
 002  01009                    LOAD s0, 09                        ;Set GPIOB0 as output and GPIOB1 as input
 003  2D0E8                    OUTPUT s0, E8[GPIO_MODEB_REG2]
 004  01002                    LOAD s0, 02
 005  2D0EA                    OUTPUT s0, EA[GPIO_IRQB_MASK]      ; Enable GPIOB1 rising IRQ
 006  01800                    LOAD s8, 00
 007  2D800                    OUTPUT s8, 00[ISR_VECTOR]          ; Clean pending IRQ
 008  28001                    ENABLE INTERRUPT
 009                gpio_loop: ; Toggle GPIOB0 every 1ms
 009  2002F                    CALL 02F[DELAY_1MS]
 00A  090E6                    INPUT s0, E6[GPIO_B]
 00B  07001                    XOR s0, 01
 00C  2D0E6                    OUTPUT s0, E6[GPIO_B]
 00D  22009                    JUMP 009[gpio_loop]
 00E  25000                    RETURN 
 00F              hello_wordl: 
 00F  01B0C                    LOAD sB, 0C[hellow'upper]
 010  01A6B                    LOAD sA, 6B[hellow'lower]
 011  20CA3                    CALL CA3[DMA_TX_STR]
 012  25000                    RETURN 
 013                main_task: 
 013  01000                    LOAD s0, 00
 014  2D020                    OUTPUT s0, 20[RX_STORE_CNT]
 015  2D022                    OUTPUT s0, 22[RX_STORE_BASE]
 016  0105F                    LOAD s0, 5F                        ;
 017  2D0E2                    OUTPUT s0, E2[GPIO_MODEA_REG2]
 018  01055                    LOAD s0, 55                        ;
 019  2D0E1                    OUTPUT s0, E1[GPIO_MODEA_REG1]
 01A  01002                    LOAD s0, 02
 01B  2D0E3                    OUTPUT s0, E3[GPIO_AFMODEA_REG]
 01C  01082                    LOAD s0, 82
 01D  2D0D0                    OUTPUT s0, D0[RS232_CONF]
 01E  01000                    LOAD s0, 00
 01F  2D000                    OUTPUT s0, 00[ISR_VECTOR]
 020  28001                    ENABLE INTERRUPT
 021               gpio_loop2: 
 021  010FF                    LOAD s0, FF
 022  2002B                    CALL 02B[DELAY_MS]
 023  010FF                    LOAD s0, FF
 024  2002B                    CALL 02B[DELAY_MS]
 025  091E0                    INPUT s1, E0[GPIO_A]
 026  07104                    XOR s1, 04
 027  2D1E0                    OUTPUT s1, E0[GPIO_A]
 028  22021                    JUMP 021[gpio_loop2]
 029  25000                    RETURN 
 02A  25000                    RETURN 
 02B                 DELAY_MS: 
 02B  2002F                    CALL 02F[DELAY_1MS]
 02C  19001                    SUB s0, 01
 02D  3602B                    JUMP NZ, 02B[DELAY_MS]
 02E  25000                    RETURN 
 02F                DELAY_1MS: 
 02F  01800                    LOAD s8, 00
 030  01900                    LOAD s9, 00
 031           DELAY_1MS_LOOP: 
 031  11808                    ADD s8, 08
 032  13900                    ADDCY s9, 00
 033  1D94E                    COMPARE s9, 4E
 034  3A031                    JUMP C, 031[DELAY_1MS_LOOP]
 035  25000                    RETURN 
 036         DMA_CH1_CALLBACK: 
 036  25000                    RETURN 
 037         DMA_CH2_CALLBACK: 
 037  25000                    RETURN 
 038         DMA_CH3_CALLBACK: 
 038  25000                    RETURN 
 039           GPIOA_CALLBACK: 
 039  25000                    RETURN 
 03A           GPIOB_CALLBACK: 
 03A  2000F                    CALL 00F[hello_wordl]
 03B  25000                    RETURN 
 03C              TX_CALLBACK: 
 03C  25000                    RETURN 
 A80                           ADDRESS A80
 A80              RX_CALLBACK: 
 A80  099D3                    INPUT s9, D3[RS232_RX_DAT]         ;> Load RX data
 A81  1D90A                    COMPARE s9, 0A[ASCII_LF]           ;> Check end of line
 A82  32A8D                    JUMP Z, A8D[NEW_COMMAND]
 A83  09A20                    INPUT sA, 20[RX_STORE_CNT]         ;> Load mem counter
 A84  00BA0                    LOAD sB, sA
 A85  11B22                    ADD sB, 22[RX_STORE_BASE]          ;> Calc save address
 A86  2C9B0                    OUTPUT s9, (sB)                    ;> Store new value
 A87  11A01                    ADD sA, 01                         ;> Increment counter
 A88                           ; Avoid memory overflow
 A88  1DA0F                    COMPARE sA, 0F                     ;> Compare counter with max value
 A89  3AA8B                    JUMP C, A8B[RX_INBOUND]
 A8A  19A01                    SUB sA, 01                         ;> if greater, return to previus value
 A8B               RX_INBOUND: 
 A8B  2DA20                    OUTPUT sA, 20[RX_STORE_CNT]        ;> Store count value
 A8C  25000                    RETURN                             ;> Return
 A8D              NEW_COMMAND: 
 A8D                           ; Some sintax sugar
 A8D                           NAMEREG s9, cmdDir
 A8D                           NAMEREG sA, cmd
 A8D                           NAMEREG sB, pinN
 A8D                           NAMEREG sC, modeMask
 A8D                           NAMEREG sD, pinMask
 A8D                           NAMEREG sE, ModeReg
 A8D                           NAMEREG sF, gpioPort
 A8D                           NAMEREG s7, tmp
 A8D                           NAMEREG s8, mode
 A8D                           ; Get the first command character
 A8D  01922                    LOAD s9[cmdDir], 22[RX_STORE_BASE] ;> Store input value pointer
 A8E  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load first input value
 A8F  1DA47                    COMPARE sA[cmd], 47[ASCII_G]       ;> Look for GPIO command
 A90  32A96                    JUMP Z, A96[GPIO_CMD]
 A91  1DA54                    COMPARE sA[cmd], 54[ASCII_T]       ;> Look for TEMP command
 A92  32BCE                    JUMP Z, BCE[TEMP_CMD]
 A93  1DA52                    COMPARE sA[cmd], 52[ASCII_R]       ;> Look for REGISTER command
 A94  32C02                    JUMP Z, C02[REG_CMD]
 A95  22C56                    JUMP C56[ERROR_CMD]                ;> If no matching commad, clear registers
 A96                           ; When GPIO command
 A96                 GPIO_CMD: 
 A96  11902                    ADD s9[cmdDir], 02                 ;> Increment pointer
 A97  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Get port
 A98  01FE0                    LOAD sF[gpioPort], E0[GPIO_A]      ;> Load GPIOA as default
 A99  1DA41                    COMPARE sA[cmd], 41[ASCII_A]       ;> Check if GPIOA
 A9A  32A9C                    JUMP Z, A9C[GPIO_GET_PIN]          ;> If correct, continue
 A9B  01FE6                    LOAD sF[gpioPort], E6[GPIO_B]      ;> If no GPIOA, change to GPIOB
 A9C                           ; Calculate PIN and registers
 A9C             GPIO_GET_PIN: 
 A9C  11901                    ADD s9[cmdDir], 01                 ;> Increment pointer
 A9D  08B90                    INPUT sB[pinN], (s9[cmdDir])       ;> Load pin value
 A9E  19B30                    SUB sB[pinN], 30                   ;> Convert to ASCII to DEC
 A9F  3AC56                    JUMP C, C56[ERROR_CMD]             ;> Check underflow. If true, the value is invalid so,
 AA0                           ;> go to clean registers. (FAIL)
 AA0  1DB08                    COMPARE sB[pinN], 08               ;> Check if pin below 8 (MAX PIN)
 AA1  3AAA3                    JUMP C, AA3[GPIO_CALC_MASK]        ;> if less than, continue
 AA2  22C56                    JUMP C56[ERROR_CMD]                ;> if greater/equal, the values is invalid (FAIL)
 AA3                           ; Calculate PIN MASK and MODE MASK
 AA3           GPIO_CALC_MASK: 
 AA3  01D01                    LOAD sD[pinMask], 01               ;> Set deault pin mask (PIN0)
 AA4  01C03                    LOAD sC[modeMask], 03              ;> Set default mode mask (INPUT)
 AA5  007B0                    LOAD s7[tmp], sB[pinN]             ;> Save pin value
 AA6           GPIO_MASK_LOOP: 
 AA6  1D700                    COMPARE s7[tmp], 00                ;> check pin counter equal 0
 AA7  32AAD                    JUMP Z, AAD[GPIO_CMD_SELECT]       ;> if true, continue
 AA8  14C02                    RL sC[modeMask]                    ;> Rotate left two positions mode mask
 AA9  14C02                    RL sC[modeMask]                    ;>
 AAA  14D02                    RL sD[pinMask]                     ;> Rotate left one position pin
 AAB  19701                    SUB s7[tmp], 01                    ;> Decrement pin counter
 AAC  22AA6                    JUMP AA6[GPIO_MASK_LOOP]
 AAD                           ; Check command type
 AAD          GPIO_CMD_SELECT: 
 AAD  01922                    LOAD s9[cmdDir], 22[RX_STORE_BASE] ;> Load base pointer
 AAE  11901                    ADD s9[cmdDir], 01                 ;> Increment pointer one position
 AAF  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Read command character
 AB0  1DA43                    COMPARE sA[cmd], 43[ASCII_C]       ;> Check configurarion command
 AB1  32AB7                    JUMP Z, AB7[GPIO_CONF_CMD]
 AB2  1DA53                    COMPARE sA[cmd], 53[ASCII_S]       ;> Check set command
 AB3  32BC5                    JUMP Z, BC5[GPIO_SET_CMD]
 AB4  1DA52                    COMPARE sA[cmd], 52[ASCII_R]       ;> Check reset command
 AB5  32BC9                    JUMP Z, BC9[GPIO_RESET_CMD]
 AB6  22C56                    JUMP C56[ERROR_CMD]
 AB7                           ; When configuration command
 AB7            GPIO_CONF_CMD: 
 AB7  11903                    ADD s9[cmdDir], 03                 ;> Increment pointer one position
 AB8  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Read command character
 AB9  01E02                    LOAD sE[ModeReg], 02               ;> Load modeReg2 offsert
 ABA  1DB04                    COMPARE sB[pinN], 04               ;> Check if offset is correct
 ABB  3AABD                    JUMP C, ABD[GPIO_CONTINUE]
 ABC  01E01                    LOAD sE[ModeReg], 01               ;> Load modeReg1 offset
 ABD            GPIO_CONTINUE: 
 ABD  10EF0                    ADD sE[ModeReg], sF[gpioPort]      ;> Calc modereg address
 ABE  1DA30                    COMPARE sA[cmd], 30[ASCII_0]       ;> Configure mode output
 ABF  32ACB                    JUMP Z, ACB[GPIO_CONF_OUT]
 AC0  1DA31                    COMPARE sA[cmd], 31[ASCII_1]       ;> Configure mode intput
 AC1  32B80                    JUMP Z, B80[GPIO_CONF_IN]
 AC2  1DA32                    COMPARE sA[cmd], 32[ASCII_2]       ;> Configure mode input irq rissing
 AC3  32B89                    JUMP Z, B89[GPIO_CONF_OR]
 AC4  1DA33                    COMPARE sA[cmd], 33[ASCII_3]       ;> Configure mode input irq falling
 AC5  32B9A                    JUMP Z, B9A[GPIO_CONF_OF]
 AC6  1DA34                    COMPARE sA[cmd], 34[ASCII_4]       ;> Configure mode AF input
 AC7  32BAA                    JUMP Z, BAA[GPIO_CONF_AFI]
 AC8  1DA35                    COMPARE sA[cmd], 35[ASCII_5]       ;> Configure AF output
 AC9  32BB4                    JUMP Z, BB4[GPIO_CONF_AFO]
 ACA  22C56                    JUMP C56[ERROR_CMD]
 ACB            GPIO_CONF_OUT: 
 ACB  01855                    LOAD s8[mode], 55                  ;> Load mode mask (all pin on)
 ACC  22BBD                    JUMP BBD[GPIO_CONF_PIN]            ;> Configure
 B80                           ADDRESS B80
 B80             GPIO_CONF_IN: 
 B80  018AA                    LOAD s8[mode], AA                  ;> Load mode mask (all pin on)
 B81  009F0                    LOAD s9[cmdDir], sF[gpioPort]      ;> Load GPIO port
 B82  11904                    ADD s9[cmdDir], 04                 ;> Calc IRQ reg address
 B83  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load IRQ reg value
 B84  07DFF                    XOR sD[pinMask], FF                ;> No pinMask value
 B85  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clean current conf
 B86  07DFF                    XOR sD[pinMask], FF                ;> Restore pinMask
 B87  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> Save register
 B88  22BBD                    JUMP BBD[GPIO_CONF_PIN]            ;> Configure
 B89             GPIO_CONF_OR: 
 B89  018AA                    LOAD s8[mode], AA                  ;> Load mode mask (all pin on)
 B8A  009F0                    LOAD s9[cmdDir], sF[gpioPort]      ;> Load GPIO port
 B8B  11904                    ADD s9[cmdDir], 04                 ;> Calc IRQ reg address
 B8C  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load IRQ reg value
 B8D  07DFF                    XOR sD[pinMask], FF                ;> No pinMask value
 B8E  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clean current conf
 B8F  07DFF                    XOR sD[pinMask], FF                ;> Restore pinMask
 B90  04AD0                    OR sA[cmd], sD[pinMask]            ;> Set IRQ enable
 B91  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> Save register
 B92  11901                    ADD s9[cmdDir], 01                 ;> Calc IRQ mode register
 B93  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load IRQ mode value
 B94  07DFF                    XOR sD[pinMask], FF                ;> Not pin mask value
 B95  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clean current conf
 B96  07DFF                    XOR sD[pinMask], FF                ;> Restore pinMask
 B97  04AD0                    OR sA[cmd], sD[pinMask]            ;> Set IRQ enable
 B98  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> Save register
 B99  22BBD                    JUMP BBD[GPIO_CONF_PIN]
 B9A             GPIO_CONF_OF: 
 B9A  018AA                    LOAD s8[mode], AA                  ;> Load mode mask (all pin on)
 B9B  009F0                    LOAD s9[cmdDir], sF[gpioPort]      ;> Load GPIO port
 B9C  11904                    ADD s9[cmdDir], 04                 ;> Calc IRQ reg address
 B9D  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load IRQ reg value
 B9E  07DFF                    XOR sD[pinMask], FF                ;> No pinMask value
 B9F  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clean current conf
 BA0  07DFF                    XOR sD[pinMask], FF                ;> Restore pinMask
 BA1  04AD0                    OR sA[cmd], sD[pinMask]            ;> Set IRQ enable
 BA2  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> Save register
 BA3  11901                    ADD s9[cmdDir], 01                 ;> Calc IRQ mode register
 BA4  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load IRQ mode value
 BA5  07DFF                    XOR sD[pinMask], FF                ;> Not pin mask value
 BA6  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clean current conf
 BA7  07DFF                    XOR sD[pinMask], FF                ;> Restore pinMask
 BA8  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> Save register
 BA9  22BBD                    JUMP BBD[GPIO_CONF_PIN]
 BAA            GPIO_CONF_AFI: 
 BAA  018FF                    LOAD s8[mode], FF                  ;> Load mode mask (all pin on)
 BAB  009F0                    LOAD s9[cmdDir], sF[gpioPort]      ;> Load GPIO port
 BAC  11903                    ADD s9[cmdDir], 03                 ;> Calc AF mode address
 BAD  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Get AF mode vlaue
 BAE  07DFF                    XOR sD[pinMask], FF                ;> Not pinmask
 BAF  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clear current value
 BB0  07DFF                    XOR sD[pinMask], FF                ;> restore pin mask
 BB1  04AD0                    OR sA[cmd], sD[pinMask]            ;> Set mode
 BB2  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> save value
 BB3  22BBD                    JUMP BBD[GPIO_CONF_PIN]
 BB4            GPIO_CONF_AFO: 
 BB4  018FF                    LOAD s8[mode], FF                  ;> Load mode mask (all pin on)
 BB5  009F0                    LOAD s9[cmdDir], sF[gpioPort]      ;> Load GPIO port
 BB6  11903                    ADD s9[cmdDir], 03                 ;> Calc AF mode address
 BB7  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Get AF mode vlaue
 BB8  07DFF                    XOR sD[pinMask], FF                ;> Not pinmask
 BB9  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clear current value
 BBA  07DFF                    XOR sD[pinMask], FF                ;> restore pin mask
 BBB  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> save value
 BBC  22BBD                    JUMP BBD[GPIO_CONF_PIN]
 BBD            GPIO_CONF_PIN: 
 BBD  08AE0                    INPUT sA[cmd], (sE[ModeReg])       ;> Get current mode reg
 BBE  07CFF                    XOR sC[modeMask], FF               ;> Not mode mask
 BBF  02AC0                    AND sA[cmd], sC[modeMask]          ;> Clean current value
 BC0  07CFF                    XOR sC[modeMask], FF               ;> Restore pinMask
 BC1  028C0                    AND s8[mode], sC[modeMask]         ;> set pin mode (only selected pin)
 BC2  04A80                    OR sA[cmd], s8[mode]               ;> Update mode reg
 BC3  2CAE0                    OUTPUT sA[cmd], (sE[ModeReg])      ;> Set mode reg
 BC4  22C5B                    JUMP C5B[OK_CMD]                   ;> Clean data
 BC5             GPIO_SET_CMD: 
 BC5  08AF0                    INPUT sA[cmd], (sF[gpioPort])      ;> Get current GPIO reg
 BC6  04AD0                    OR sA[cmd], sD[pinMask]            ;> Update GPIO reg
 BC7  2CAF0                    OUTPUT sA[cmd], (sF[gpioPort])     ;> set new GPIO reg
 BC8  22C5B                    JUMP C5B[OK_CMD]                   ;> Clean data
 BC9           GPIO_RESET_CMD: 
 BC9  08AF0                    INPUT sA[cmd], (sF[gpioPort])      ;> Get current GPIO reg
 BCA  07DFF                    XOR sD[pinMask], FF                ;> Update GPIO reg. (NOT is not implemented so, we use XOR)
 BCB  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clean bit
 BCC  2CAF0                    OUTPUT sA[cmd], (sF[gpioPort])     ;> Set new GPIO reg
 BCD  22C5B                    JUMP C5B[OK_CMD]                   ;> Clean data
 BCE                           NAMEREG pinN, sB
 BCE                           NAMEREG modeMask, sC
 BCE                           NAMEREG pinMask, sD
 BCE                           NAMEREG ModeReg, sE
 BCE                           NAMEREG gpioPort, sF
 BCE                           NAMEREG tmp, s7
 BCE                           NAMEREG mode, s8
 BCE                 TEMP_CMD: 
 BCE                           NAMEREG sB, cmd2
 BCE  11901                    ADD s9[cmdDir], 01
 BCF  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load cmd
 BD0  1DA53                    COMPARE sA[cmd], 53[ASCII_S]
 BD1  32BE8                    JUMP Z, BE8[SET_TEMP_CMD]
 BD2  1DA47                    COMPARE sA[cmd], 47[ASCII_G]
 BD3  32BD4                    JUMP Z, BD4[GET_TEMP_CMD]
 BD4             GET_TEMP_CMD: 
 BD4  09ADA                    INPUT sA[cmd], DA[DISPLAY_01]
 BD5  00BA0                    LOAD sB[cmd2], sA[cmd]
 BD6  14A0E                    SR0 sA[cmd]
 BD7  14A0E                    SR0 sA[cmd]
 BD8  14A0E                    SR0 sA[cmd]
 BD9  14A0E                    SR0 sA[cmd]
 BDA  03B0F                    AND sB[cmd2], 0F
 BDB  11A30                    ADD sA[cmd], 30
 BDC  11B30                    ADD sB[cmd2], 30
 BDD  20CD5                    CALL CD5[WAIT_DMA_CH1]
 BDE  0191A                    LOAD s9[cmdDir], 1A[DMA_STR_BASE]
 BDF  2CB90                    OUTPUT sB[cmd2], (s9[cmdDir])
 BE0  11901                    ADD s9[cmdDir], 01
 BE1  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])
 BE2  11901                    ADD s9[cmdDir], 01
 BE3  01A0A                    LOAD sA[cmd], 0A[ASCII_LF]
 BE4  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])
 BE5  01002                    LOAD s0, 02
 BE6  20CAF                    CALL CAF[DMA_TX_LOAD]
 BE7  22C60                    JUMP C60[CLC_CMD]
 BE8             SET_TEMP_CMD: 
 BE8  11901                    ADD s9[cmdDir], 01
 BE9  08A90                    INPUT sA[cmd], (s9[cmdDir])
 BEA  19A30                    SUB sA[cmd], 30
 BEB  3AC56                    JUMP C, C56[ERROR_CMD]
 BEC  1DA0A                    COMPARE sA[cmd], 0A
 BED  3ABEF                    JUMP C, BEF[SET_TEMP_CONT1]
 BEE  22C56                    JUMP C56[ERROR_CMD]
 BEF           SET_TEMP_CONT1: 
 BEF  11901                    ADD s9[cmdDir], 01
 BF0  08B90                    INPUT sB[cmd2], (s9[cmdDir])
 BF1  19B30                    SUB sB[cmd2], 30
 BF2  3AC56                    JUMP C, C56[ERROR_CMD]
 BF3  1DB0A                    COMPARE sB[cmd2], 0A
 BF4  3ABF6                    JUMP C, BF6[SET_TEMP_CONT2]
 BF5  22C56                    JUMP C56[ERROR_CMD]
 BF6           SET_TEMP_CONT2: 
 BF6  14A06                    SL0 sA[cmd]
 BF7  14A06                    SL0 sA[cmd]
 BF8  14A06                    SL0 sA[cmd]
 BF9  14A06                    SL0 sA[cmd]
 BFA  03B0F                    AND sB[cmd2], 0F
 BFB  04AB0                    OR sA[cmd], sB[cmd2]
 BFC  2DADA                    OUTPUT sA[cmd], DA[DISPLAY_01]
 BFD  01A03                    LOAD sA[cmd], 03
 BFE  2DAD9                    OUTPUT sA[cmd], D9[DISPLAY_IEN]
 BFF  01A80                    LOAD sA[cmd], 80
 C00  2DAD8                    OUTPUT sA[cmd], D8[DISPLAY_EN]
 C01  22C5B                    JUMP C5B[OK_CMD]
 C02                  REG_CMD: 
 C02  11901                    ADD s9[cmdDir], 01
 C03  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load cmd
 C04  1DA53                    COMPARE sA[cmd], 53[ASCII_S]
 C05  32C31                    JUMP Z, C31[SET_REG_CMD]
 C06  1DA47                    COMPARE sA[cmd], 47[ASCII_G]
 C07  32C09                    JUMP Z, C09[GET_REG_CMD]
 C08  22C56                    JUMP C56[ERROR_CMD]                ;> Clean data
 C09              GET_REG_CMD: 
 C09  11901                    ADD s9[cmdDir], 01
 C0A  08090                    INPUT s0, (s9[cmdDir])
 C0B  20CBE                    CALL CBE[HEX2DEC]
 C0C  003F0                    LOAD s3, sF
 C0D  1DFFF                    COMPARE sF, FF
 C0E  32C56                    JUMP Z, C56[ERROR_CMD]             ;
 C0F  11901                    ADD s9[cmdDir], 01
 C10  08090                    INPUT s0, (s9[cmdDir])
 C11  20CBE                    CALL CBE[HEX2DEC]
 C12  1DFFF                    COMPARE sF, FF
 C13  32C56                    JUMP Z, C56[ERROR_CMD]             ;
 C14  14306                    SL0 s3
 C15  14306                    SL0 s3
 C16  14306                    SL0 s3
 C17  14306                    SL0 s3
 C18  033FF                    AND s3, FF
 C19  043F0                    OR s3, sF
 C1A  08030                    INPUT s0, (s3)
 C1B  00400                    LOAD s4, s0
 C1C  1400E                    SR0 s0
 C1D  1400E                    SR0 s0
 C1E  1400E                    SR0 s0
 C1F  1400E                    SR0 s0
 C20  0340F                    AND s4, 0F
 C21  20CCC                    CALL CCC[DEC2HEX]
 C22  00310                    LOAD s3, s1
 C23  00040                    LOAD s0, s4
 C24  20CCC                    CALL CCC[DEC2HEX]
 C25  00A10                    LOAD sA[cmd], s1
 C26  20CD5                    CALL CD5[WAIT_DMA_CH1]
 C27  0191A                    LOAD s9[cmdDir], 1A[DMA_STR_BASE]
 C28  2C390                    OUTPUT s3, (s9[cmdDir])
 C29  11901                    ADD s9[cmdDir], 01
 C2A  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])
 C2B  11901                    ADD s9[cmdDir], 01
 C2C  01A0A                    LOAD sA[cmd], 0A[ASCII_LF]
 C2D  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])
 C2E  01002                    LOAD s0, 02
 C2F  20CAF                    CALL CAF[DMA_TX_LOAD]
 C30  22C60                    JUMP C60[CLC_CMD]
 C31              SET_REG_CMD: 
 C31  11901                    ADD s9[cmdDir], 01
 C32  08090                    INPUT s0, (s9[cmdDir])
 C33  20CBE                    CALL CBE[HEX2DEC]
 C34  003F0                    LOAD s3, sF
 C35  1DFFF                    COMPARE sF, FF
 C36  32C56                    JUMP Z, C56[ERROR_CMD]             ;
 C37  11901                    ADD s9[cmdDir], 01
 C38  08090                    INPUT s0, (s9[cmdDir])
 C39  20CBE                    CALL CBE[HEX2DEC]
 C3A  1DFFF                    COMPARE sF, FF
 C3B  32C56                    JUMP Z, C56[ERROR_CMD]             ;
 C3C  14306                    SL0 s3
 C3D  14306                    SL0 s3
 C3E  14306                    SL0 s3
 C3F  14306                    SL0 s3
 C40  033FF                    AND s3, FF
 C41  043F0                    OR s3, sF
 C42  00430                    LOAD s4, s3                        ;DONDE VOY S4
 C43  11901                    ADD s9[cmdDir], 01
 C44  08090                    INPUT s0, (s9[cmdDir])
 C45  20CBE                    CALL CBE[HEX2DEC]
 C46  003F0                    LOAD s3, sF
 C47  1DFFF                    COMPARE sF, FF
 C48  32C56                    JUMP Z, C56[ERROR_CMD]             ;
 C49  11901                    ADD s9[cmdDir], 01
 C4A  08090                    INPUT s0, (s9[cmdDir])
 C4B  20CBE                    CALL CBE[HEX2DEC]
 C4C  1DFFF                    COMPARE sF, FF
 C4D  32C56                    JUMP Z, C56[ERROR_CMD]             ;
 C4E  14306                    SL0 s3
 C4F  14306                    SL0 s3
 C50  14306                    SL0 s3
 C51  14306                    SL0 s3
 C52  033FF                    AND s3, FF
 C53  043F0                    OR s3, sF
 C54  2C340                    OUTPUT s3, (s4)
 C55  22C5B                    JUMP C5B[OK_CMD]
 C56                           NAMEREG cmd2, sB
 C56                           NAMEREG cmdDir, s9
 C56                           NAMEREG cmd, sA
 C56                ERROR_CMD: 
 C56  01B0C                    LOAD sB, 0C[errormsg'upper]
 C57  01A9B                    LOAD sA, 9B[errormsg'lower]
 C58  20CD5                    CALL CD5[WAIT_DMA_CH1]
 C59  20CA3                    CALL CA3[DMA_TX_STR]
 C5A  22C60                    JUMP C60[CLC_CMD]
 C5B                   OK_CMD: 
 C5B  01B0C                    LOAD sB, 0C[okmsg'upper]
 C5C  01A97                    LOAD sA, 97[okmsg'lower]
 C5D  20CD5                    CALL CD5[WAIT_DMA_CH1]
 C5E  20CA3                    CALL CA3[DMA_TX_STR]
 C5F  22C60                    JUMP C60[CLC_CMD]
 C60                  CLC_CMD: 
 C60                           ; Restore register names
 C60  09B20                    INPUT sB, 20[RX_STORE_CNT]         ;> Get counter
 C61  01C00                    LOAD sC, 00                        ;> Set 0 value
 C62  2DC20                    OUTPUT sC, 20[RX_STORE_CNT]
 C63  0DB00                    TEST sB, 00
 C64  32C6A                    JUMP Z, C6A[END_END]
 C65             LOOP_CMD_CLC: 
 C65  01A22                    LOAD sA, 22[RX_STORE_BASE]         ;> Load base register
 C66  10AB0                    ADD sA, sB                         ;> Set address
 C67  2CCA0                    OUTPUT sC, (sA)                    ;> Clean register
 C68  19B01                    SUB sB, 01                         ;> decrement counter
 C69  36C65                    JUMP NZ, C65[LOOP_CMD_CLC]         ;> While not 0
 C6A                  END_END: 
 C6A  25000                    RETURN 
 C6B  21148            hellow: LOAD&RETURN s1, 48[SAYHELLOW$:"H"]
 C6C  21165                    LOAD&RETURN s1, 65[SAYHELLOW$:"e"]
 C6D  2116C                    LOAD&RETURN s1, 6C[SAYHELLOW$:"l"]
 C6E  2116C                    LOAD&RETURN s1, 6C[SAYHELLOW$:"l"]
 C6F  2116F                    LOAD&RETURN s1, 6F[SAYHELLOW$:"o"]
 C70  21120                    LOAD&RETURN s1, 20[SAYHELLOW$:" "]
 C71  21157                    LOAD&RETURN s1, 57[SAYHELLOW$:"W"]
 C72  2116F                    LOAD&RETURN s1, 6F[SAYHELLOW$:"o"]
 C73  21172                    LOAD&RETURN s1, 72[SAYHELLOW$:"r"]
 C74  2116C                    LOAD&RETURN s1, 6C[SAYHELLOW$:"l"]
 C75  21164                    LOAD&RETURN s1, 64[SAYHELLOW$:"d"]
 C76  21121                    LOAD&RETURN s1, 21[SAYHELLOW$:"!"]
 C77  2110A                    LOAD&RETURN s1, 0A[ASCII_LF]
 C78  21151            cajero: LOAD&RETURN s1, 51[MERCADONA$:"Q"]
 C79  21175                    LOAD&RETURN s1, 75[MERCADONA$:"u"]
 C7A  21169                    LOAD&RETURN s1, 69[MERCADONA$:"i"]
 C7B  21165                    LOAD&RETURN s1, 65[MERCADONA$:"e"]
 C7C  21172                    LOAD&RETURN s1, 72[MERCADONA$:"r"]
 C7D  21165                    LOAD&RETURN s1, 65[MERCADONA$:"e"]
 C7E  21120                    LOAD&RETURN s1, 20[MERCADONA$:" "]
 C7F  21162                    LOAD&RETURN s1, 62[MERCADONA$:"b"]
 C80  2116F                    LOAD&RETURN s1, 6F[MERCADONA$:"o"]
 C81  2116C                    LOAD&RETURN s1, 6C[MERCADONA$:"l"]
 C82  21173                    LOAD&RETURN s1, 73[MERCADONA$:"s"]
 C83  21161                    LOAD&RETURN s1, 61[MERCADONA$:"a"]
 C84  2113F                    LOAD&RETURN s1, 3F[MERCADONA$:"?"]
 C85  2110A                    LOAD&RETURN s1, 0A[ASCII_LF]
 C86  21130              hexv: LOAD&RETURN s1, 30[HEXAVAL$:"0"]
 C87  21131                    LOAD&RETURN s1, 31[HEXAVAL$:"1"]
 C88  21132                    LOAD&RETURN s1, 32[HEXAVAL$:"2"]
 C89  21133                    LOAD&RETURN s1, 33[HEXAVAL$:"3"]
 C8A  21134                    LOAD&RETURN s1, 34[HEXAVAL$:"4"]
 C8B  21135                    LOAD&RETURN s1, 35[HEXAVAL$:"5"]
 C8C  21136                    LOAD&RETURN s1, 36[HEXAVAL$:"6"]
 C8D  21137                    LOAD&RETURN s1, 37[HEXAVAL$:"7"]
 C8E  21138                    LOAD&RETURN s1, 38[HEXAVAL$:"8"]
 C8F  21139                    LOAD&RETURN s1, 39[HEXAVAL$:"9"]
 C90  21141                    LOAD&RETURN s1, 41[HEXAVAL$:"A"]
 C91  21142                    LOAD&RETURN s1, 42[HEXAVAL$:"B"]
 C92  21143                    LOAD&RETURN s1, 43[HEXAVAL$:"C"]
 C93  21144                    LOAD&RETURN s1, 44[HEXAVAL$:"D"]
 C94  21145                    LOAD&RETURN s1, 45[HEXAVAL$:"E"]
 C95  21146                    LOAD&RETURN s1, 46[HEXAVAL$:"F"]
 C96  2110D                    LOAD&RETURN s1, 0D
 C97  2114F             okmsg: LOAD&RETURN s1, 4F[ACK$:"O"]
 C98  2114B                    LOAD&RETURN s1, 4B[ACK$:"K"]
 C99  21121                    LOAD&RETURN s1, 21[ACK$:"!"]
 C9A  2110A                    LOAD&RETURN s1, 0A[ASCII_LF]
 C9B  21145          errormsg: LOAD&RETURN s1, 45[NACK$:"E"]
 C9C  21152                    LOAD&RETURN s1, 52[NACK$:"R"]
 C9D  21152                    LOAD&RETURN s1, 52[NACK$:"R"]
 C9E  2114F                    LOAD&RETURN s1, 4F[NACK$:"O"]
 C9F  21152                    LOAD&RETURN s1, 52[NACK$:"R"]
 CA0  21121                    LOAD&RETURN s1, 21[NACK$:"!"]
 CA1  21121                    LOAD&RETURN s1, 21[NACK$:"!"]
 CA2  2110A                    LOAD&RETURN s1, 0A[ASCII_LF]
 CA3                           ;LOAD sA and sB with the string load address
 CA3               DMA_TX_STR: 
 CA3  01000                    LOAD s0, 00
 CA4  0121A                    LOAD s2, 1A[DMA_STR_BASE]
 CA5          DMA_TX_STR_LOOP: 
 CA5  24BA0                    CALL@ (sB, sA)                     ; Get character
 CA6  0121A                    LOAD s2, 1A[DMA_STR_BASE]          ; Load address
 CA7  10200                    ADD s2, s0                         ; Calc pointer
 CA8  2C120                    OUTPUT s1, (s2)                    ; Save to RAM
 CA9  1D10A                    COMPARE s1, 0A[ASCII_LF]           ; When LF
 CAA  32CAF                    JUMP Z, CAF[DMA_TX_LOAD]           ; Go to load
 CAB  11001                    ADD s0, 01                         ; inc counter
 CAC  11A01                    ADD sA, 01                         ; inc address
 CAD  13B00                    ADDCY sB, 00                       ; Carry
 CAE  22CA5                    JUMP CA5[DMA_TX_STR_LOOP]          ; loop
 CAF              DMA_TX_LOAD: 
 CAF  011D2                    LOAD s1, D2[RS232_TX_DATA]         ; set estination pointer
 CB0  2D1C2                    OUTPUT s1, C2[DMA_DEST_CH1]        ;
 CB1  0111A                    LOAD s1, 1A[DMA_STR_BASE]          ; Set character source
 CB2  2D1C1                    OUTPUT s1, C1[DMA_SRC_CH1]         ;
 CB3  0300F                    AND s0, 0F                         ; Update DMA counter
 CB4  05010                    OR s0, 10                          ;
 CB5  2D0C3                    OUTPUT s0, C3[DMA_CNT_CH1]         ; Save counter
 CB6  010A0                    LOAD s0, A0                        ; Enable DMA
 CB7  2D0C0                    OUTPUT s0, C0[DMA_CONF_CH1]        ;
 CB8  0901A                    INPUT s0, 1A[DMA_STR_BASE]         ; Read first char
 CB9  2D0D2                    OUTPUT s0, D2[RS232_TX_DATA]       ; Save to tx reg
 CBA  090D0                    INPUT s0, D0[RS232_CONF]
 CBB  05044                    OR s0, 44                          ; Enable TX with DMA
 CBC  2D0D0                    OUTPUT s0, D0[RS232_CONF]          ;
 CBD  25000                    RETURN 
 CBE                  HEX2DEC: 
 CBE  01B0C                    LOAD sB, 0C[hexv'upper]
 CBF  01A86                    LOAD sA, 86[hexv'lower]
 CC0  01F00                    LOAD sF, 00
 CC1                   HEXCMP: 
 CC1  24BA0                    CALL@ (sB, sA)
 CC2  1C100                    COMPARE s1, s0
 CC3  32CCB                    JUMP Z, CCB[HEXVAL_RETURN]
 CC4  11A01                    ADD sA, 01
 CC5  13B00                    ADDCY sB, 00
 CC6  11F01                    ADD sF, 01
 CC7  1D1D0                    COMPARE s1, D0
 CC8  32CCA                    JUMP Z, CCA[HEX_VAL_ERROR]
 CC9  22CC1                    JUMP CC1[HEXCMP]
 CCA            HEX_VAL_ERROR: 
 CCA  01FFF                    LOAD sF, FF
 CCB            HEXVAL_RETURN: 
 CCB  25000                    RETURN 
 CCC                  DEC2HEX: 
 CCC  01B0C                    LOAD sB, 0C[hexv'upper]
 CCD  01A86                    LOAD sA, 86[hexv'lower]
 CCE  1D010                    COMPARE s0, 10
 CCF  3ACD1                    JUMP C, CD1[DEC2HEX_C]
 CD0  25000                    RETURN 
 CD1                DEC2HEX_C: 
 CD1  10A00                    ADD sA, s0
 CD2  13B00                    ADDCY sB, 00
 CD3  24BA0                    CALL@ (sB, sA)
 CD4  25000                    RETURN 
 CD5             WAIT_DMA_CH1: 
 CD5  090C0                    INPUT s0, C0[DMA_CONF_CH1]
 CD6  0D080                    TEST s0, 80
 CD7  36CD5                    JUMP NZ, CD5[WAIT_DMA_CH1]
 CD8  25000                    RETURN 
 CD9              OK_CMD_TEST: 
 CD9  01B0C                    LOAD sB, 0C[okmsg'upper]
 CDA  01A97                    LOAD sA, 97[okmsg'lower]
 CDB  20CD5                    CALL CD5[WAIT_DMA_CH1]
 CDC  20CA3                    CALL CA3[DMA_TX_STR]
 CDD  20CD5                    CALL CD5[WAIT_DMA_CH1]
 CDE  25000                    RETURN 
 F80                           ADDRESS F80
 F80                      ISR: 
 F80                           ;    DISABLE INTERRUPT
 F80  37001                    REGBANK B
 F81  09800                    INPUT s8, 00[ISR_VECTOR]           ;Read ISR vector
 F82                           ; Check DMA IRQ
 F82  0D801                    TEST s8, 01[DMA_CH1_IRQ_MASK]      ;DMA Channel 1
 F83  34036                    CALL NZ, 036[DMA_CH1_CALLBACK]
 F84  0D802                    TEST s8, 02[DMA_CH2_IRQ_MASK]      ;DMA Channel 2
 F85  34037                    CALL NZ, 037[DMA_CH2_CALLBACK]
 F86  0D804                    TEST s8, 04[DMA_CH3_IRQ_MASK]      ;DMA Channel 3
 F87  34038                    CALL NZ, 038[DMA_CH3_CALLBACK]
 F88                           ; Check GPIO IRQ
 F88  0D840                    TEST s8, 40[GPIOA_IRQ_MASK]        ;GPIOA
 F89  34039                    CALL NZ, 039[GPIOA_CALLBACK]
 F8A  0D880                    TEST s8, 80[GPIOB_IRQ_MASK]        ;GPIOB
 F8B  3403A                    CALL NZ, 03A[GPIOB_CALLBACK]
 F8C                           ; Check RS232 IRQ
 F8C  0D810                    TEST s8, 10[TX_IRQ_MASK]           ;RS232 TX
 F8D  3403C                    CALL NZ, 03C[TX_CALLBACK]
 F8E  0D820                    TEST s8, 20[RX_IRQ_MASK]           ;RS232 RX
 F8F  34A80                    CALL NZ, A80[RX_CALLBACK]
 F90  01800                    LOAD s8, 00
 F91  2D800                    OUTPUT s8, 00[ISR_VECTOR]          ;Clean vector
 F92  37000                    REGBANK A
 F93  29001                    RETURNI ENABLE


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

D:\OneDrive\Documentos\Universidad\LCSE\entregas\LCSE_PROJ\src\program\rom.psm



List of defined constants

 CONSTANT name      Value        Source PSM File

 timestamp_hours    13'd         
 timestamp_minutes  01'd         
 timestamp_seconds  21'd         
 datestamp_year     20'd         
 datestamp_month    11'd         
 datestamp_day      21'd         
 NUL                00           
 BEL                07           
 BS                 08           
 HT                 09           
 LF                 0A           
 VT                 0B           
 CR                 0D           
 ESC                1B           
 DEL                7F           
 DCS                90           
 ST                 9C           
 sRAM               10           rom.psm
 eRAM               1F           rom.psm
 DMA_MEM_BASE       C0           rom.psm
 DMA_CONF_CH1       C0           rom.psm
 DMA_SRC_CH1        C1           rom.psm
 DMA_DEST_CH1       C2           rom.psm
 DMA_CNT_CH1        C3           rom.psm
 DMA_CONF_CH2       C4           rom.psm
 DMA_SRC_CH2        C5           rom.psm
 DMA_DEST_CH2       C6           rom.psm
 DMA_CNT_CH2        C7           rom.psm
 DMA_CONF_CH3       C8           rom.psm
 DMA_SRC_CH3        C9           rom.psm
 DMA_DEST_CH3       CA           rom.psm
 DMA_CNT_CH3        CB           rom.psm
 RS232_BASE         D0           rom.psm
 RS232_CONF         D0           rom.psm
 RS232_STATUS       D1           rom.psm
 RS232_TX_DATA      D2           rom.psm
 RS232_RX_DAT       D3           rom.psm
 GPIO_BASE          E0           rom.psm
 GPIO_A             E0           rom.psm
 GPIO_MODEA_REG1    E1           rom.psm
 GPIO_MODEA_REG2    E2           rom.psm
 GPIO_AFMODEA_REG   E3           rom.psm
 GPIO_IRQA_MASK     E4           rom.psm
 GPIO_IRQMODEA_MASK E5           rom.psm
 GPIO_B             E6           rom.psm
 GPIO_MODEB_REG1    E7           rom.psm
 GPIO_MODEB_REG2    E8           rom.psm
 GPIO_AFMODEB_REG   E9           rom.psm
 GPIO_IRQB_MASK     EA           rom.psm
 GPIO_IRQMODEB_MASK EB           rom.psm
 DISPLAY_EN         D8           rom.psm
 DISPLAY_IEN        D9           rom.psm
 DISPLAY_01         DA           rom.psm
 DISPLAY_23         DB           rom.psm
 DISPLAY_45         DC           rom.psm
 DISPLAY_67         DD           rom.psm
 ISR_VECTOR         00           rom.psm
 DMA_CH1_IRQ_MASK   01           rom.psm
 DMA_CH2_IRQ_MASK   02           rom.psm
 DMA_CH3_IRQ_MASK   04           rom.psm
 TX_IRQ_MASK        10           rom.psm
 RX_IRQ_MASK        20           rom.psm
 GPIOA_IRQ_MASK     40           rom.psm
 GPIOB_IRQ_MASK     80           rom.psm
 ASCII_LF           0A           rom.psm
 ASCII_0            30           rom.psm
 ASCII_1            31           rom.psm
 ASCII_2            32           rom.psm
 ASCII_3            33           rom.psm
 ASCII_4            34           rom.psm
 ASCII_5            35           rom.psm
 ASCII_6            36           rom.psm
 ASCII_7            37           rom.psm
 ASCII_8            38           rom.psm
 ASCII_9            39           rom.psm
 ASCII_A            41           rom.psm
 ASCII_B            42           rom.psm
 ASCII_C            43           rom.psm
 ASCII_D            44           rom.psm
 ASCII_E            45           rom.psm
 ASCII_F            46           rom.psm
 ASCII_G            47           rom.psm
 ASCII_H            48           rom.psm
 ASCII_I            49           rom.psm
 ASCII_J            4A           rom.psm
 ASCII_K            4B           rom.psm
 ASCII_L            4C           rom.psm
 ASCII_M            4D           rom.psm
 ASCII_N            4E           rom.psm
 ASCII_O            4F           rom.psm
 ASCII_P            50           rom.psm
 ASCII_Q            51           rom.psm
 ASCII_R            52           rom.psm
 ASCII_S            53           rom.psm
 ASCII_T            54           rom.psm
 ASCII_U            55           rom.psm
 ASCII_V            56           rom.psm
 ASCII_W            57           rom.psm
 ASCII_X            58           rom.psm
 ASCII_Y            59           rom.psm
 ASCII_Z            5A           rom.psm
 RX_STORE_CNT       20           rom.psm
 RX_STORE_BASE      22           rom.psm
 DMA_STR_BASE       1A           rom.psm



No TABLEs defined



List of text strings

 STRING name       String              Source PSM File

 KCPSM6_version$   "v2.70"             
 datestamp$        "21 Nov 2020"       
 timestamp$        "13:01:21"          
 HEXAVAL$          "0123456789ABCDEF"  rom.psm
 SAYHELLOW$        "Hello World!"      rom.psm
 MERCADONA$        "Quiere bolsa?"     rom.psm
 NACK$             "ERROR!!"           rom.psm
 ACK$              "OK!"               rom.psm
 PENE$             "Quiere bolsa?"     rom.psm



List of line labels

   Label              Addr  Source PSM File

 * start              000   rom.psm
   loop               001   rom.psm
 * gpio_test          002   rom.psm
   gpio_loop          009   rom.psm
   hello_wordl        00F   rom.psm
   main_task          013   rom.psm
   gpio_loop2         021   rom.psm
   DELAY_MS           02B   rom.psm
   DELAY_1MS          02F   rom.psm
   DELAY_1MS_LOOP     031   rom.psm
   DMA_CH1_CALLBACK   036   rom.psm
   DMA_CH2_CALLBACK   037   rom.psm
   DMA_CH3_CALLBACK   038   rom.psm
   GPIOA_CALLBACK     039   rom.psm
   GPIOB_CALLBACK     03A   rom.psm
   TX_CALLBACK        03C   rom.psm
   RX_CALLBACK        A80   rom.psm
   RX_INBOUND         A8B   rom.psm
   NEW_COMMAND        A8D   rom.psm
   GPIO_CMD           A96   rom.psm
   GPIO_GET_PIN       A9C   rom.psm
   GPIO_CALC_MASK     AA3   rom.psm
   GPIO_MASK_LOOP     AA6   rom.psm
   GPIO_CMD_SELECT    AAD   rom.psm
   GPIO_CONF_CMD      AB7   rom.psm
   GPIO_CONTINUE      ABD   rom.psm
   GPIO_CONF_OUT      ACB   rom.psm
   GPIO_CONF_IN       B80   rom.psm
   GPIO_CONF_OR       B89   rom.psm
   GPIO_CONF_OF       B9A   rom.psm
   GPIO_CONF_AFI      BAA   rom.psm
   GPIO_CONF_AFO      BB4   rom.psm
   GPIO_CONF_PIN      BBD   rom.psm
   GPIO_SET_CMD       BC5   rom.psm
   GPIO_RESET_CMD     BC9   rom.psm
   TEMP_CMD           BCE   rom.psm
   GET_TEMP_CMD       BD4   rom.psm
   SET_TEMP_CMD       BE8   rom.psm
   SET_TEMP_CONT1     BEF   rom.psm
   SET_TEMP_CONT2     BF6   rom.psm
   REG_CMD            C02   rom.psm
   GET_REG_CMD        C09   rom.psm
   SET_REG_CMD        C31   rom.psm
   ERROR_CMD          C56   rom.psm
   OK_CMD             C5B   rom.psm
   CLC_CMD            C60   rom.psm
   LOOP_CMD_CLC       C65   rom.psm
   END_END            C6A   rom.psm
   hellow             C6B   rom.psm
 * cajero             C78   rom.psm
   hexv               C86   rom.psm
   okmsg              C97   rom.psm
   errormsg           C9B   rom.psm
   DMA_TX_STR         CA3   rom.psm
   DMA_TX_STR_LOOP    CA5   rom.psm
   DMA_TX_LOAD        CAF   rom.psm
   HEX2DEC            CBE   rom.psm
   HEXCMP             CC1   rom.psm
   HEX_VAL_ERROR      CCA   rom.psm
   HEXVAL_RETURN      CCB   rom.psm
   DEC2HEX            CCC   rom.psm
   DEC2HEX_C          CD1   rom.psm
   WAIT_DMA_CH1       CD5   rom.psm
 * OK_CMD_TEST        CD9   rom.psm
 * ISR                F80   rom.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             74
 STAR              -

 AND              17
 OR               12
 XOR              19

 ADD              38
 ADDCY             4
 SUB               7
 SUBCY             -

 TEST              9
 TESTCY            -
 COMPARE          35
 COMPARECY         -

 SL0              16
 SL1               -
 SLX               -
 SLA               -
 RL                3
 SR0               8
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           2

 INPUT            36
 OUTPUT           44
 OUTPUTK           -

 STORE             -
 FETCH             -

 DISABLE           -
 ENABLE            2
 RETURNI           1

 JUMP             70
 JUMP@             -
 CALL             33
 CALL@             3
 RETURN           20
 LOAD&RETURN      56

 HWBUILD           -



End of KCPSM6 log file.

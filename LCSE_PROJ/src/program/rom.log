KCPSM6 Assembler log file for program 'D:\OneDrive\Documentos\Universidad\LCSE\entregas\LCSE_PROJ\src\program\rom.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 14 Nov 2020
Assembly timestamp: 19:36:22

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: F92 hex
Nominal program memory size: 4K (4096)   address(11:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 467
Memory locations available: 3629


Assembly listing

 Addr Code                     Instruction

 000                           ; LCSE picoblaze test program
 000                           ;Memory Map definition
 000                           CONSTANT sRAM, 10                  ; RAM Start address
 000                           CONSTANT eRAM, 1F                  ; RAM end address
 000                           CONSTANT DMA_MEM_BASE, C0          ;
 000                           CONSTANT DMA_CONF_CH1, C0          ;
 000                           CONSTANT DMA_SRC_CH1, C1           ;
 000                           CONSTANT DMA_DEST_CH1, C2          ;
 000                           CONSTANT DMA_CNT_CH1, C3           ;
 000                           CONSTANT DMA_CONF_CH2, C4          ;
 000                           CONSTANT DMA_SRC_CH2, C5           ;
 000                           CONSTANT DMA_DEST_CH2, C6          ;
 000                           CONSTANT DMA_CNT_CH2, C7           ;
 000                           CONSTANT DMA_CONF_CH3, C8          ;
 000                           CONSTANT DMA_SRC_CH3, C9           ;
 000                           CONSTANT DMA_DEST_CH3, CA          ;
 000                           CONSTANT DMA_CNT_CH3, CB           ;
 000                           CONSTANT RS232_BASE, D0            ;
 000                           CONSTANT RS232_CONF, D0            ;
 000                           CONSTANT RS232_STATUS, D1          ;
 000                           CONSTANT RS232_TX_DATA, D2         ;
 000                           CONSTANT RS232_RX_DAT, D3          ;
 000                           CONSTANT GPIO_BASE, E0             ;
 000                           CONSTANT GPIO_A, E0                ;
 000                           CONSTANT GPIO_MODEA_REG1, E1       ;
 000                           CONSTANT GPIO_MODEA_REG2, E2       ;
 000                           CONSTANT GPIO_AFMODEA_REG, E3      ;
 000                           CONSTANT GPIO_IRQA_MASK, E4        ;
 000                           CONSTANT GPIO_IRQMODEA_MASK, E5    ;
 000                           CONSTANT GPIO_B, E6                ;
 000                           CONSTANT GPIO_MODEB_REG1, E7       ;
 000                           CONSTANT GPIO_MODEB_REG2, E8       ;
 000                           CONSTANT GPIO_AFMODEB_REG, E9
 000                           CONSTANT GPIO_IRQB_MASK, EA        ;
 000                           CONSTANT GPIO_IRQMODEB_MASK, EB    ;
 000                           CONSTANT DISPLAY_EN, D8            ;
 000                           CONSTANT DISPLAY_IEN, D9           ;
 000                           CONSTANT DISPLAY_01, DA            ;
 000                           CONSTANT DISPLAY_23, DB            ;
 000                           CONSTANT DISPLAY_45, DC            ;
 000                           CONSTANT DISPLAY_67, DD            ;
 000                           CONSTANT ISR_VECTOR, 00            ;
 000                           CONSTANT DMA_CH1_IRQ_MASK, 01
 000                           CONSTANT DMA_CH2_IRQ_MASK, 02
 000                           CONSTANT DMA_CH3_IRQ_MASK, 04
 000                           CONSTANT TX_IRQ_MASK, 10
 000                           CONSTANT RX_IRQ_MASK, 20
 000                           CONSTANT GPIOA_IRQ_MASK, 40
 000                           CONSTANT GPIOB_IRQ_MASK, 80
 000                           ; COMMADS -> ASCII to hex
 000                           CONSTANT ASCII_LF, 0A
 000                           CONSTANT ASCII_0, 30
 000                           CONSTANT ASCII_1, 31
 000                           CONSTANT ASCII_2, 32
 000                           CONSTANT ASCII_3, 33
 000                           CONSTANT ASCII_4, 34
 000                           CONSTANT ASCII_5, 35
 000                           CONSTANT ASCII_6, 36
 000                           CONSTANT ASCII_7, 37
 000                           CONSTANT ASCII_8, 38
 000                           CONSTANT ASCII_9, 39
 000                           CONSTANT ASCII_A, 41
 000                           CONSTANT ASCII_B, 42
 000                           CONSTANT ASCII_C, 43
 000                           CONSTANT ASCII_D, 44
 000                           CONSTANT ASCII_E, 45
 000                           CONSTANT ASCII_F, 46
 000                           CONSTANT ASCII_G, 47
 000                           CONSTANT ASCII_H, 48
 000                           CONSTANT ASCII_I, 49
 000                           CONSTANT ASCII_J, 4A
 000                           CONSTANT ASCII_K, 4B
 000                           CONSTANT ASCII_L, 4C
 000                           CONSTANT ASCII_M, 4D
 000                           CONSTANT ASCII_N, 4E
 000                           CONSTANT ASCII_O, 4F
 000                           CONSTANT ASCII_P, 50
 000                           CONSTANT ASCII_Q, 51
 000                           CONSTANT ASCII_R, 52
 000                           CONSTANT ASCII_S, 53
 000                           CONSTANT ASCII_T, 54
 000                           CONSTANT ASCII_U, 55
 000                           CONSTANT ASCII_V, 56
 000                           CONSTANT ASCII_W, 57
 000                           CONSTANT ASCII_X, 58
 000                           CONSTANT ASCII_Y, 59
 000                           CONSTANT ASCII_Z, 5A
 000                           STRING HEXAVAL$, "0123456789ABCDEF"
 000                           STRING SAYHELLOW$, "Hello World!"
 000                           STRING MERCADONA$, "Quiere bolsa?"
 000                           STRING NACK$, "ERROR!"
 000                           STRING ACK$, "OK!"
 000                           ; Static memory pointers
 000                           CONSTANT RX_STORE_CNT, 10
 000                           CONSTANT RX_STORE_BASE, 11
 000                           CONSTANT DMA_STR_BASE, 1A
 000                    start: 
 000  01000                    LOAD s0, 00
 001  2D010                    OUTPUT s0, 10[RX_STORE_CNT]
 002  2D011                    OUTPUT s0, 11[RX_STORE_BASE]
 003  0100C                    LOAD s0, 0C                        ;
 004  2D0E2                    OUTPUT s0, E2[GPIO_MODEA_REG2]
 005  01002                    LOAD s0, 02
 006  2D0E3                    OUTPUT s0, E3[GPIO_AFMODEA_REG]
 007  01082                    LOAD s0, 82
 008  2D0D0                    OUTPUT s0, D0[RS232_CONF]
 009  01800                    LOAD s8, 00
 00A  2D800                    OUTPUT s8, 00[ISR_VECTOR]
 00B  28001                    ENABLE INTERRUPT
 00C  2200C              loop: JUMP 00C[loop]
 00D                 DELAY_MS: 
 00D  20011                    CALL 011[DELAY_1MS]
 00E  19001                    SUB s0, 01
 00F  3600D                    JUMP NZ, 00D[DELAY_MS]
 010  25000                    RETURN 
 011                DELAY_1MS: 
 011  01800                    LOAD s8, 00
 012  01900                    LOAD s9, 00
 013           DELAY_1MS_LOOP: 
 013  11808                    ADD s8, 08
 014  13900                    ADDCY s9, 00
 015  1D94E                    COMPARE s9, 4E
 016  3A013                    JUMP C, 013[DELAY_1MS_LOOP]
 017  25000                    RETURN 
 018         DMA_CH1_CALLBACK: 
 018  25000                    RETURN 
 019         DMA_CH2_CALLBACK: 
 019  25000                    RETURN 
 01A         DMA_CH3_CALLBACK: 
 01A  25000                    RETURN 
 01B           GPIOA_CALLBACK: 
 01B  25000                    RETURN 
 01C           GPIOB_CALLBACK: 
 01C  25000                    RETURN 
 01D              TX_CALLBACK: 
 01D  25000                    RETURN 
 A80                           ADDRESS A80
 A80              RX_CALLBACK: 
 A80  099D3                    INPUT s9, D3[RS232_RX_DAT]         ;> Load RX data
 A81  1D90A                    COMPARE s9, 0A[ASCII_LF]           ;> Check end of line
 A82  32A8D                    JUMP Z, A8D[NEW_COMMAND]
 A83  09A10                    INPUT sA, 10[RX_STORE_CNT]         ;> Load mem counter
 A84  00BA0                    LOAD sB, sA
 A85  11B11                    ADD sB, 11[RX_STORE_BASE]          ;> Calc save address
 A86  2C9B0                    OUTPUT s9, (sB)                    ;> Store new value
 A87  11A01                    ADD sA, 01                         ;> Increment counter
 A88                           ; Avoid memory overflow
 A88  1DA08                    COMPARE sA, 08                     ;> Compare counter with max value
 A89  3AA8B                    JUMP C, A8B[RX_INBOUND]
 A8A  19A01                    SUB sA, 01                         ;> if greater, return to previus value
 A8B               RX_INBOUND: 
 A8B  2DA10                    OUTPUT sA, 10[RX_STORE_CNT]        ;> Store count value
 A8C  25000                    RETURN                             ;> Return
 A8D              NEW_COMMAND: 
 A8D                           ; Some sintax sugar
 A8D                           NAMEREG s9, cmdDir
 A8D                           NAMEREG sA, cmd
 A8D                           NAMEREG sB, pinN
 A8D                           NAMEREG sC, modeMask
 A8D                           NAMEREG sD, pinMask
 A8D                           NAMEREG sE, ModeReg
 A8D                           NAMEREG sF, gpioPort
 A8D                           NAMEREG s7, tmp
 A8D                           NAMEREG s8, mode
 A8D                           ; Get the first command character
 A8D  01911                    LOAD s9[cmdDir], 11[RX_STORE_BASE] ;> Store input value pointer
 A8E  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load first input value
 A8F  1DA47                    COMPARE sA[cmd], 47[ASCII_G]       ;> Look for GPIO command
 A90  32A96                    JUMP Z, A96[GPIO_CMD]
 A91  1DA54                    COMPARE sA[cmd], 54[ASCII_T]       ;> Look for TEMP command
 A92  32BCE                    JUMP Z, BCE[TEMP_CMD]
 A93  1DA52                    COMPARE sA[cmd], 52[ASCII_R]       ;> Look for REGISTER command
 A94  32C02                    JUMP Z, C02[REG_CMD]
 A95  22C56                    JUMP C56[ERROR_CMD]                ;> If no matching commad, clear registers
 A96                           ; When GPIO command
 A96                 GPIO_CMD: 
 A96  11902                    ADD s9[cmdDir], 02                 ;> Increment pointer
 A97  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Get port
 A98  01FE0                    LOAD sF[gpioPort], E0[GPIO_A]      ;> Load GPIOA as default
 A99  1DA41                    COMPARE sA[cmd], 41[ASCII_A]       ;> Check if GPIOA
 A9A  32A9C                    JUMP Z, A9C[GPIO_GET_PIN]          ;> If correct, continue
 A9B  01FE6                    LOAD sF[gpioPort], E6[GPIO_B]      ;> If no GPIOA, change to GPIOB
 A9C                           ; Calculate PIN and registers
 A9C             GPIO_GET_PIN: 
 A9C  11901                    ADD s9[cmdDir], 01                 ;> Increment pointer
 A9D  08B90                    INPUT sB[pinN], (s9[cmdDir])       ;> Load pin value
 A9E  19B30                    SUB sB[pinN], 30                   ;> Convert to ASCII to DEC
 A9F  3AC56                    JUMP C, C56[ERROR_CMD]             ;> Check underflow. If true, the value is invalid so,
 AA0                           ;> go to clean registers. (FAIL)
 AA0  1DB08                    COMPARE sB[pinN], 08               ;> Check if pin below 8 (MAX PIN)
 AA1  3AAA3                    JUMP C, AA3[GPIO_CALC_MASK]        ;> if less than, continue
 AA2  22C56                    JUMP C56[ERROR_CMD]                ;> if greater/equal, the values is invalid (FAIL)
 AA3                           ; Calculate PIN MASK and MODE MASK
 AA3           GPIO_CALC_MASK: 
 AA3  01D01                    LOAD sD[pinMask], 01               ;> Set deault pin mask (PIN0)
 AA4  01C03                    LOAD sC[modeMask], 03              ;> Set default mode mask (INPUT)
 AA5  007B0                    LOAD s7[tmp], sB[pinN]             ;> Save pin value
 AA6           GPIO_MASK_LOOP: 
 AA6  1D700                    COMPARE s7[tmp], 00                ;> check pin counter equal 0
 AA7  32AAD                    JUMP Z, AAD[GPIO_CMD_SELECT]       ;> if true, continue
 AA8  14C02                    RL sC[modeMask]                    ;> Rotate left two positions mode mask
 AA9  14C02                    RL sC[modeMask]                    ;>
 AAA  14D02                    RL sD[pinMask]                     ;> Rotate left one position pin
 AAB  19701                    SUB s7[tmp], 01                    ;> Decrement pin counter
 AAC  22AA6                    JUMP AA6[GPIO_MASK_LOOP]
 AAD                           ; Check command type
 AAD          GPIO_CMD_SELECT: 
 AAD  01911                    LOAD s9[cmdDir], 11[RX_STORE_BASE] ;> Load base pointer
 AAE  11901                    ADD s9[cmdDir], 01                 ;> Increment pointer one position
 AAF  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Read command character
 AB0  1DA43                    COMPARE sA[cmd], 43[ASCII_C]       ;> Check configurarion command
 AB1  32AB7                    JUMP Z, AB7[GPIO_CONF_CMD]
 AB2  1DA53                    COMPARE sA[cmd], 53[ASCII_S]       ;> Check set command
 AB3  32BC5                    JUMP Z, BC5[GPIO_SET_CMD]
 AB4  1DA52                    COMPARE sA[cmd], 52[ASCII_R]       ;> Check reset command
 AB5  32BC9                    JUMP Z, BC9[GPIO_RESET_CMD]
 AB6  22C56                    JUMP C56[ERROR_CMD]
 AB7                           ; When configuration command
 AB7            GPIO_CONF_CMD: 
 AB7  11903                    ADD s9[cmdDir], 03                 ;> Increment pointer one position
 AB8  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Read command character
 AB9  01E02                    LOAD sE[ModeReg], 02               ;> Load modeReg2 offsert
 ABA  1DB04                    COMPARE sB[pinN], 04               ;> Check if offset is correct
 ABB  3AABD                    JUMP C, ABD[GPIO_CONTINUE]
 ABC  01E01                    LOAD sE[ModeReg], 01               ;> Load modeReg1 offset
 ABD            GPIO_CONTINUE: 
 ABD  10EF0                    ADD sE[ModeReg], sF[gpioPort]      ;> Calc modereg address
 ABE  1DA30                    COMPARE sA[cmd], 30[ASCII_0]       ;> Configure mode output
 ABF  32ACB                    JUMP Z, ACB[GPIO_CONF_OUT]
 AC0  1DA31                    COMPARE sA[cmd], 31[ASCII_1]       ;> Configure mode intput
 AC1  32B80                    JUMP Z, B80[GPIO_CONF_IN]
 AC2  1DA32                    COMPARE sA[cmd], 32[ASCII_2]       ;> Configure mode input irq rissing
 AC3  32B89                    JUMP Z, B89[GPIO_CONF_OR]
 AC4  1DA33                    COMPARE sA[cmd], 33[ASCII_3]       ;> Configure mode input irq falling
 AC5  32B9A                    JUMP Z, B9A[GPIO_CONF_OF]
 AC6  1DA34                    COMPARE sA[cmd], 34[ASCII_4]       ;> Configure mode AF input
 AC7  32BAA                    JUMP Z, BAA[GPIO_CONF_AFI]
 AC8  1DA35                    COMPARE sA[cmd], 35[ASCII_5]       ;> Configure AF output
 AC9  32BB4                    JUMP Z, BB4[GPIO_CONF_AFO]
 ACA  22C60                    JUMP C60[CLC_CMD]
 ACB            GPIO_CONF_OUT: 
 ACB  01855                    LOAD s8[mode], 55                  ;> Load mode mask (all pin on)
 ACC  22BBD                    JUMP BBD[GPIO_CONF_PIN]            ;> Configure
 B80                           ADDRESS B80
 B80             GPIO_CONF_IN: 
 B80  018AA                    LOAD s8[mode], AA                  ;> Load mode mask (all pin on)
 B81  009F0                    LOAD s9[cmdDir], sF[gpioPort]      ;> Load GPIO port
 B82  11904                    ADD s9[cmdDir], 04                 ;> Calc IRQ reg address
 B83  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load IRQ reg value
 B84  07DFF                    XOR sD[pinMask], FF                ;> No pinMask value
 B85  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clean current conf
 B86  07DFF                    XOR sD[pinMask], FF                ;> Restore pinMask
 B87  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> Save register
 B88  22BBD                    JUMP BBD[GPIO_CONF_PIN]            ;> Configure
 B89             GPIO_CONF_OR: 
 B89  018AA                    LOAD s8[mode], AA                  ;> Load mode mask (all pin on)
 B8A  009F0                    LOAD s9[cmdDir], sF[gpioPort]      ;> Load GPIO port
 B8B  11904                    ADD s9[cmdDir], 04                 ;> Calc IRQ reg address
 B8C  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load IRQ reg value
 B8D  07DFF                    XOR sD[pinMask], FF                ;> No pinMask value
 B8E  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clean current conf
 B8F  07DFF                    XOR sD[pinMask], FF                ;> Restore pinMask
 B90  04AD0                    OR sA[cmd], sD[pinMask]            ;> Set IRQ enable
 B91  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> Save register
 B92  11901                    ADD s9[cmdDir], 01                 ;> Calc IRQ mode register
 B93  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load IRQ mode value
 B94  07DFF                    XOR sD[pinMask], FF                ;> Not pin mask value
 B95  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clean current conf
 B96  07DFF                    XOR sD[pinMask], FF                ;> Restore pinMask
 B97  04AD0                    OR sA[cmd], sD[pinMask]            ;> Set IRQ enable
 B98  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> Save register
 B99  22BBD                    JUMP BBD[GPIO_CONF_PIN]
 B9A             GPIO_CONF_OF: 
 B9A  018AA                    LOAD s8[mode], AA                  ;> Load mode mask (all pin on)
 B9B  009F0                    LOAD s9[cmdDir], sF[gpioPort]      ;> Load GPIO port
 B9C  11904                    ADD s9[cmdDir], 04                 ;> Calc IRQ reg address
 B9D  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load IRQ reg value
 B9E  07DFF                    XOR sD[pinMask], FF                ;> No pinMask value
 B9F  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clean current conf
 BA0  07DFF                    XOR sD[pinMask], FF                ;> Restore pinMask
 BA1  04AD0                    OR sA[cmd], sD[pinMask]            ;> Set IRQ enable
 BA2  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> Save register
 BA3  11901                    ADD s9[cmdDir], 01                 ;> Calc IRQ mode register
 BA4  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load IRQ mode value
 BA5  07DFF                    XOR sD[pinMask], FF                ;> Not pin mask value
 BA6  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clean current conf
 BA7  07DFF                    XOR sD[pinMask], FF                ;> Restore pinMask
 BA8  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> Save register
 BA9  22BBD                    JUMP BBD[GPIO_CONF_PIN]
 BAA            GPIO_CONF_AFI: 
 BAA  018FF                    LOAD s8[mode], FF                  ;> Load mode mask (all pin on)
 BAB  009F0                    LOAD s9[cmdDir], sF[gpioPort]      ;> Load GPIO port
 BAC  11903                    ADD s9[cmdDir], 03                 ;> Calc AF mode address
 BAD  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Get AF mode vlaue
 BAE  07DFF                    XOR sD[pinMask], FF                ;> Not pinmask
 BAF  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clear current value
 BB0  07DFF                    XOR sD[pinMask], FF                ;> restore pin mask
 BB1  04AD0                    OR sA[cmd], sD[pinMask]            ;> Set mode
 BB2  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> save value
 BB3  22BBD                    JUMP BBD[GPIO_CONF_PIN]
 BB4            GPIO_CONF_AFO: 
 BB4  018FF                    LOAD s8[mode], FF                  ;> Load mode mask (all pin on)
 BB5  009F0                    LOAD s9[cmdDir], sF[gpioPort]      ;> Load GPIO port
 BB6  11903                    ADD s9[cmdDir], 03                 ;> Calc AF mode address
 BB7  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Get AF mode vlaue
 BB8  07DFF                    XOR sD[pinMask], FF                ;> Not pinmask
 BB9  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clear current value
 BBA  07DFF                    XOR sD[pinMask], FF                ;> restore pin mask
 BBB  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])       ;> save value
 BBC  22BBD                    JUMP BBD[GPIO_CONF_PIN]
 BBD            GPIO_CONF_PIN: 
 BBD  08AE0                    INPUT sA[cmd], (sE[ModeReg])       ;> Get current mode reg
 BBE  07CFF                    XOR sC[modeMask], FF               ;> Not mode mask
 BBF  02AC0                    AND sA[cmd], sC[modeMask]          ;> Clean current value
 BC0  07CFF                    XOR sC[modeMask], FF               ;> Restore pinMask
 BC1  028C0                    AND s8[mode], sC[modeMask]         ;> set pin mode (only selected pin)
 BC2  04A80                    OR sA[cmd], s8[mode]               ;> Update mode reg
 BC3  2CAE0                    OUTPUT sA[cmd], (sE[ModeReg])      ;> Set mode reg
 BC4  22C5B                    JUMP C5B[OK_CMD]                   ;> Clean data
 BC5             GPIO_SET_CMD: 
 BC5  08AF0                    INPUT sA[cmd], (sF[gpioPort])      ;> Get current GPIO reg
 BC6  04AD0                    OR sA[cmd], sD[pinMask]            ;> Update GPIO reg
 BC7  2CAF0                    OUTPUT sA[cmd], (sF[gpioPort])     ;> set new GPIO reg
 BC8  22C5B                    JUMP C5B[OK_CMD]                   ;> Clean data
 BC9           GPIO_RESET_CMD: 
 BC9  08AF0                    INPUT sA[cmd], (sF[gpioPort])      ;> Get current GPIO reg
 BCA  07DFF                    XOR sD[pinMask], FF                ;> Update GPIO reg. (NOT is not implemented so, we use XOR)
 BCB  02AD0                    AND sA[cmd], sD[pinMask]           ;> Clean bit
 BCC  2CAF0                    OUTPUT sA[cmd], (sF[gpioPort])     ;> Set new GPIO reg
 BCD  22C5B                    JUMP C5B[OK_CMD]                   ;> Clean data
 BCE                           NAMEREG pinN, sB
 BCE                           NAMEREG modeMask, sC
 BCE                           NAMEREG pinMask, sD
 BCE                           NAMEREG ModeReg, sE
 BCE                           NAMEREG gpioPort, sF
 BCE                           NAMEREG tmp, s7
 BCE                           NAMEREG mode, s8
 BCE                 TEMP_CMD: 
 BCE                           NAMEREG sB, cmd2
 BCE  11901                    ADD s9[cmdDir], 01
 BCF  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load cmd
 BD0  1DA53                    COMPARE sA[cmd], 53[ASCII_S]
 BD1  32BE8                    JUMP Z, BE8[SET_TEMP_CMD]
 BD2  1DA47                    COMPARE sA[cmd], 47[ASCII_G]
 BD3  32BD4                    JUMP Z, BD4[GET_TEMP_CMD]
 BD4             GET_TEMP_CMD: 
 BD4  09ADA                    INPUT sA[cmd], DA[DISPLAY_01]
 BD5  00BA0                    LOAD sB[cmd2], sA[cmd]
 BD6  14A0E                    SR0 sA[cmd]
 BD7  14A0E                    SR0 sA[cmd]
 BD8  14A0E                    SR0 sA[cmd]
 BD9  14A0E                    SR0 sA[cmd]
 BDA  03B0F                    AND sB[cmd2], 0F
 BDB  11A30                    ADD sA[cmd], 30
 BDC  11B30                    ADD sB[cmd2], 30
 BDD  20CD1                    CALL CD1[WAIT_DMA_CH1]
 BDE  0191A                    LOAD s9[cmdDir], 1A[DMA_STR_BASE]
 BDF  2CB90                    OUTPUT sB[cmd2], (s9[cmdDir])
 BE0  11901                    ADD s9[cmdDir], 01
 BE1  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])
 BE2  11901                    ADD s9[cmdDir], 01
 BE3  01A0A                    LOAD sA[cmd], 0A[ASCII_LF]
 BE4  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])
 BE5  01002                    LOAD s0, 02
 BE6  20CAC                    CALL CAC[DMA_TX_LOAD]
 BE7  22C60                    JUMP C60[CLC_CMD]
 BE8             SET_TEMP_CMD: 
 BE8  11901                    ADD s9[cmdDir], 01
 BE9  08A90                    INPUT sA[cmd], (s9[cmdDir])
 BEA  19A30                    SUB sA[cmd], 30
 BEB  3AC56                    JUMP C, C56[ERROR_CMD]
 BEC  1DA0A                    COMPARE sA[cmd], 0A
 BED  3ABEF                    JUMP C, BEF[SET_TEMP_CONT1]
 BEE  22C56                    JUMP C56[ERROR_CMD]
 BEF           SET_TEMP_CONT1: 
 BEF  11901                    ADD s9[cmdDir], 01
 BF0  08B90                    INPUT sB[cmd2], (s9[cmdDir])
 BF1  19B30                    SUB sB[cmd2], 30
 BF2  3AC56                    JUMP C, C56[ERROR_CMD]
 BF3  1DB0A                    COMPARE sB[cmd2], 0A
 BF4  3ABF6                    JUMP C, BF6[SET_TEMP_CONT2]
 BF5  22C56                    JUMP C56[ERROR_CMD]
 BF6           SET_TEMP_CONT2: 
 BF6  14B06                    SL0 sB[cmd2]
 BF7  14B06                    SL0 sB[cmd2]
 BF8  14B06                    SL0 sB[cmd2]
 BF9  14B06                    SL0 sB[cmd2]
 BFA  03A0F                    AND sA[cmd], 0F
 BFB  04AB0                    OR sA[cmd], sB[cmd2]
 BFC  2DADA                    OUTPUT sA[cmd], DA[DISPLAY_01]
 BFD  01A03                    LOAD sA[cmd], 03
 BFE  2DAD9                    OUTPUT sA[cmd], D9[DISPLAY_IEN]
 BFF  01A80                    LOAD sA[cmd], 80
 C00  2DAD8                    OUTPUT sA[cmd], D8[DISPLAY_EN]
 C01  22C5B                    JUMP C5B[OK_CMD]
 C02                  REG_CMD: 
 C02  11901                    ADD s9[cmdDir], 01
 C03  08A90                    INPUT sA[cmd], (s9[cmdDir])        ;> Load cmd
 C04  1DA53                    COMPARE sA[cmd], 53[ASCII_S]
 C05  32C31                    JUMP Z, C31[SET_REG_CMD]
 C06  1DA47                    COMPARE sA[cmd], 47[ASCII_G]
 C07  32C09                    JUMP Z, C09[GET_REG_CMD]
 C08  22C56                    JUMP C56[ERROR_CMD]                ;> Clean data
 C09              GET_REG_CMD: 
 C09  11901                    ADD s9[cmdDir], 01
 C0A  08090                    INPUT s0, (s9[cmdDir])
 C0B  20CBA                    CALL CBA[HEX2DEC]
 C0C  003F0                    LOAD s3, sF
 C0D  1DFFF                    COMPARE sF, FF
 C0E  32C56                    JUMP Z, C56[ERROR_CMD]             ;
 C0F  11901                    ADD s9[cmdDir], 01
 C10  08090                    INPUT s0, (s9[cmdDir])
 C11  20CBA                    CALL CBA[HEX2DEC]
 C12  1DFFF                    COMPARE sF, FF
 C13  32C56                    JUMP Z, C56[ERROR_CMD]             ;
 C14  14306                    SL0 s3
 C15  14306                    SL0 s3
 C16  14306                    SL0 s3
 C17  14306                    SL0 s3
 C18  033FF                    AND s3, FF
 C19  043F0                    OR s3, sF
 C1A  08030                    INPUT s0, (s3)
 C1B  00400                    LOAD s4, s0
 C1C  1400E                    SR0 s0
 C1D  1400E                    SR0 s0
 C1E  1400E                    SR0 s0
 C1F  1400E                    SR0 s0
 C20  0340F                    AND s4, 0F
 C21  20CC8                    CALL CC8[DEC2HEX]
 C22  00310                    LOAD s3, s1
 C23  00040                    LOAD s0, s4
 C24  20CC8                    CALL CC8[DEC2HEX]
 C25  00A10                    LOAD sA[cmd], s1
 C26  20CD1                    CALL CD1[WAIT_DMA_CH1]
 C27  0191A                    LOAD s9[cmdDir], 1A[DMA_STR_BASE]
 C28  2C390                    OUTPUT s3, (s9[cmdDir])
 C29  11901                    ADD s9[cmdDir], 01
 C2A  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])
 C2B  11901                    ADD s9[cmdDir], 01
 C2C  01A0A                    LOAD sA[cmd], 0A[ASCII_LF]
 C2D  2CA90                    OUTPUT sA[cmd], (s9[cmdDir])
 C2E  01002                    LOAD s0, 02
 C2F  20CAC                    CALL CAC[DMA_TX_LOAD]
 C30  22C60                    JUMP C60[CLC_CMD]
 C31              SET_REG_CMD: 
 C31  11901                    ADD s9[cmdDir], 01
 C32  08090                    INPUT s0, (s9[cmdDir])
 C33  20CBA                    CALL CBA[HEX2DEC]
 C34  003F0                    LOAD s3, sF
 C35  1DFFF                    COMPARE sF, FF
 C36  32C56                    JUMP Z, C56[ERROR_CMD]             ;
 C37  11901                    ADD s9[cmdDir], 01
 C38  08090                    INPUT s0, (s9[cmdDir])
 C39  20CBA                    CALL CBA[HEX2DEC]
 C3A  1DFFF                    COMPARE sF, FF
 C3B  32C56                    JUMP Z, C56[ERROR_CMD]             ;
 C3C  14306                    SL0 s3
 C3D  14306                    SL0 s3
 C3E  14306                    SL0 s3
 C3F  14306                    SL0 s3
 C40  033FF                    AND s3, FF
 C41  043F0                    OR s3, sF
 C42  00430                    LOAD s4, s3
 C43  11901                    ADD s9[cmdDir], 01
 C44  08090                    INPUT s0, (s9[cmdDir])
 C45  20CBA                    CALL CBA[HEX2DEC]
 C46  003F0                    LOAD s3, sF
 C47  1DFFF                    COMPARE sF, FF
 C48  32C56                    JUMP Z, C56[ERROR_CMD]             ;
 C49  11901                    ADD s9[cmdDir], 01
 C4A  08090                    INPUT s0, (s9[cmdDir])
 C4B  20CBA                    CALL CBA[HEX2DEC]
 C4C  1DFFF                    COMPARE sF, FF
 C4D  32C56                    JUMP Z, C56[ERROR_CMD]             ;
 C4E  14306                    SL0 s3
 C4F  14306                    SL0 s3
 C50  14306                    SL0 s3
 C51  14306                    SL0 s3
 C52  033FF                    AND s3, FF
 C53  043F0                    OR s3, sF
 C54  2C340                    OUTPUT s3, (s4)
 C55  22C5B                    JUMP C5B[OK_CMD]
 C56                           NAMEREG cmd2, sB
 C56                           NAMEREG cmdDir, s9
 C56                           NAMEREG cmd, sA
 C56                ERROR_CMD: 
 C56  01B0C                    LOAD sB, 0C[errormsg'upper]
 C57  01A99                    LOAD sA, 99[errormsg'lower]
 C58  20CD1                    CALL CD1[WAIT_DMA_CH1]
 C59  20CA0                    CALL CA0[DMA_TX_STR]
 C5A  22C60                    JUMP C60[CLC_CMD]
 C5B                   OK_CMD: 
 C5B  01B0C                    LOAD sB, 0C[okmsg'upper]
 C5C  01A95                    LOAD sA, 95[okmsg'lower]
 C5D  20CD1                    CALL CD1[WAIT_DMA_CH1]
 C5E  20CA0                    CALL CA0[DMA_TX_STR]
 C5F  22C60                    JUMP C60[CLC_CMD]
 C60                  CLC_CMD: 
 C60                           ; Restore register names
 C60  09B10                    INPUT sB, 10[RX_STORE_CNT]         ;> Get counter
 C61  01C00                    LOAD sC, 00                        ;> Set 0 value
 C62  2DC10                    OUTPUT sC, 10[RX_STORE_CNT]
 C63             LOOP_CMD_CLC: 
 C63  01A11                    LOAD sA, 11[RX_STORE_BASE]         ;> Load base register
 C64  10AB0                    ADD sA, sB                         ;> Set address
 C65  2CCA0                    OUTPUT sC, (sA)                    ;> Clean register
 C66  19B01                    SUB sB, 01                         ;> decrement counter
 C67  36C63                    JUMP NZ, C63[LOOP_CMD_CLC]         ;> While not 0
 C68  25000                    RETURN 
 C69  21148            hellow: LOAD&RETURN s1, 48[SAYHELLOW$:"H"]
 C6A  21165                    LOAD&RETURN s1, 65[SAYHELLOW$:"e"]
 C6B  2116C                    LOAD&RETURN s1, 6C[SAYHELLOW$:"l"]
 C6C  2116C                    LOAD&RETURN s1, 6C[SAYHELLOW$:"l"]
 C6D  2116F                    LOAD&RETURN s1, 6F[SAYHELLOW$:"o"]
 C6E  21120                    LOAD&RETURN s1, 20[SAYHELLOW$:" "]
 C6F  21157                    LOAD&RETURN s1, 57[SAYHELLOW$:"W"]
 C70  2116F                    LOAD&RETURN s1, 6F[SAYHELLOW$:"o"]
 C71  21172                    LOAD&RETURN s1, 72[SAYHELLOW$:"r"]
 C72  2116C                    LOAD&RETURN s1, 6C[SAYHELLOW$:"l"]
 C73  21164                    LOAD&RETURN s1, 64[SAYHELLOW$:"d"]
 C74  21121                    LOAD&RETURN s1, 21[SAYHELLOW$:"!"]
 C75  2110A                    LOAD&RETURN s1, 0A[ASCII_LF]
 C76  21151            cajero: LOAD&RETURN s1, 51[MERCADONA$:"Q"]
 C77  21175                    LOAD&RETURN s1, 75[MERCADONA$:"u"]
 C78  21169                    LOAD&RETURN s1, 69[MERCADONA$:"i"]
 C79  21165                    LOAD&RETURN s1, 65[MERCADONA$:"e"]
 C7A  21172                    LOAD&RETURN s1, 72[MERCADONA$:"r"]
 C7B  21165                    LOAD&RETURN s1, 65[MERCADONA$:"e"]
 C7C  21120                    LOAD&RETURN s1, 20[MERCADONA$:" "]
 C7D  21162                    LOAD&RETURN s1, 62[MERCADONA$:"b"]
 C7E  2116F                    LOAD&RETURN s1, 6F[MERCADONA$:"o"]
 C7F  2116C                    LOAD&RETURN s1, 6C[MERCADONA$:"l"]
 C80  21173                    LOAD&RETURN s1, 73[MERCADONA$:"s"]
 C81  21161                    LOAD&RETURN s1, 61[MERCADONA$:"a"]
 C82  2113F                    LOAD&RETURN s1, 3F[MERCADONA$:"?"]
 C83  2110A                    LOAD&RETURN s1, 0A[ASCII_LF]
 C84  21130              hexv: LOAD&RETURN s1, 30[HEXAVAL$:"0"]
 C85  21131                    LOAD&RETURN s1, 31[HEXAVAL$:"1"]
 C86  21132                    LOAD&RETURN s1, 32[HEXAVAL$:"2"]
 C87  21133                    LOAD&RETURN s1, 33[HEXAVAL$:"3"]
 C88  21134                    LOAD&RETURN s1, 34[HEXAVAL$:"4"]
 C89  21135                    LOAD&RETURN s1, 35[HEXAVAL$:"5"]
 C8A  21136                    LOAD&RETURN s1, 36[HEXAVAL$:"6"]
 C8B  21137                    LOAD&RETURN s1, 37[HEXAVAL$:"7"]
 C8C  21138                    LOAD&RETURN s1, 38[HEXAVAL$:"8"]
 C8D  21139                    LOAD&RETURN s1, 39[HEXAVAL$:"9"]
 C8E  21141                    LOAD&RETURN s1, 41[HEXAVAL$:"A"]
 C8F  21142                    LOAD&RETURN s1, 42[HEXAVAL$:"B"]
 C90  21143                    LOAD&RETURN s1, 43[HEXAVAL$:"C"]
 C91  21144                    LOAD&RETURN s1, 44[HEXAVAL$:"D"]
 C92  21145                    LOAD&RETURN s1, 45[HEXAVAL$:"E"]
 C93  21146                    LOAD&RETURN s1, 46[HEXAVAL$:"F"]
 C94  2110D                    LOAD&RETURN s1, 0D
 C95  2114F             okmsg: LOAD&RETURN s1, 4F[ACK$:"O"]
 C96  2114B                    LOAD&RETURN s1, 4B[ACK$:"K"]
 C97  21121                    LOAD&RETURN s1, 21[ACK$:"!"]
 C98  2110A                    LOAD&RETURN s1, 0A[ASCII_LF]
 C99  21145          errormsg: LOAD&RETURN s1, 45[NACK$:"E"]
 C9A  21152                    LOAD&RETURN s1, 52[NACK$:"R"]
 C9B  21152                    LOAD&RETURN s1, 52[NACK$:"R"]
 C9C  2114F                    LOAD&RETURN s1, 4F[NACK$:"O"]
 C9D  21152                    LOAD&RETURN s1, 52[NACK$:"R"]
 C9E  21121                    LOAD&RETURN s1, 21[NACK$:"!"]
 C9F  2110A                    LOAD&RETURN s1, 0A[ASCII_LF]
 CA0                           ;LOAD sA and sB with the string load address
 CA0               DMA_TX_STR: 
 CA0  01000                    LOAD s0, 00
 CA1  0121A                    LOAD s2, 1A[DMA_STR_BASE]
 CA2          DMA_TX_STR_LOOP: 
 CA2  24BA0                    CALL@ (sB, sA)
 CA3  0121A                    LOAD s2, 1A[DMA_STR_BASE]
 CA4  10200                    ADD s2, s0
 CA5  2C120                    OUTPUT s1, (s2)
 CA6  1D10A                    COMPARE s1, 0A[ASCII_LF]
 CA7  32CAC                    JUMP Z, CAC[DMA_TX_LOAD]
 CA8  11001                    ADD s0, 01
 CA9  11A01                    ADD sA, 01
 CAA  13B00                    ADDCY sB, 00
 CAB  22CA2                    JUMP CA2[DMA_TX_STR_LOOP]
 CAC              DMA_TX_LOAD: 
 CAC  011D2                    LOAD s1, D2[RS232_TX_DATA]
 CAD  2D1C2                    OUTPUT s1, C2[DMA_DEST_CH1]
 CAE  0111A                    LOAD s1, 1A[DMA_STR_BASE]
 CAF  2D1C1                    OUTPUT s1, C1[DMA_SRC_CH1]
 CB0  0300F                    AND s0, 0F
 CB1  05010                    OR s0, 10
 CB2  2D0C3                    OUTPUT s0, C3[DMA_CNT_CH1]
 CB3  010A0                    LOAD s0, A0
 CB4  2D0C0                    OUTPUT s0, C0[DMA_CONF_CH1]
 CB5  0901A                    INPUT s0, 1A[DMA_STR_BASE]
 CB6  2D0D2                    OUTPUT s0, D2[RS232_TX_DATA]
 CB7  010C6                    LOAD s0, C6
 CB8  2D0D0                    OUTPUT s0, D0[RS232_CONF]
 CB9  25000                    RETURN 
 CBA                  HEX2DEC: 
 CBA  01B0C                    LOAD sB, 0C[hexv'upper]
 CBB  01A84                    LOAD sA, 84[hexv'lower]
 CBC  01F00                    LOAD sF, 00
 CBD                   HEXCMP: 
 CBD  24BA0                    CALL@ (sB, sA)
 CBE  1C100                    COMPARE s1, s0
 CBF  32CC7                    JUMP Z, CC7[HEXVAL_RETURN]
 CC0  11A01                    ADD sA, 01
 CC1  13B00                    ADDCY sB, 00
 CC2  11F01                    ADD sF, 01
 CC3  1D1D0                    COMPARE s1, D0
 CC4  32CC6                    JUMP Z, CC6[HEX_VAL_ERROR]
 CC5  22CBD                    JUMP CBD[HEXCMP]
 CC6            HEX_VAL_ERROR: 
 CC6  01FFF                    LOAD sF, FF
 CC7            HEXVAL_RETURN: 
 CC7  25000                    RETURN 
 CC8                  DEC2HEX: 
 CC8  01B0C                    LOAD sB, 0C[hexv'upper]
 CC9  01A84                    LOAD sA, 84[hexv'lower]
 CCA  1D010                    COMPARE s0, 10
 CCB  3ACCD                    JUMP C, CCD[DEC2HEX_C]
 CCC  25000                    RETURN 
 CCD                DEC2HEX_C: 
 CCD  10A00                    ADD sA, s0
 CCE  13B00                    ADDCY sB, 00
 CCF  24BA0                    CALL@ (sB, sA)
 CD0  25000                    RETURN 
 CD1             WAIT_DMA_CH1: 
 CD1  090C0                    INPUT s0, C0[DMA_CONF_CH1]
 CD2  0D080                    TEST s0, 80
 CD3  36CD1                    JUMP NZ, CD1[WAIT_DMA_CH1]
 CD4  25000                    RETURN 
 F80                           ADDRESS F80
 F80                      ISR: 
 F80  28000                    DISABLE INTERRUPT
 F81  09800                    INPUT s8, 00[ISR_VECTOR]           ;Read ISR vector
 F82                           ; Check DMA IRQ
 F82  0D801                    TEST s8, 01[DMA_CH1_IRQ_MASK]      ;DMA Channel 1
 F83  34018                    CALL NZ, 018[DMA_CH1_CALLBACK]
 F84  0D802                    TEST s8, 02[DMA_CH2_IRQ_MASK]      ;DMA Channel 2
 F85  34019                    CALL NZ, 019[DMA_CH2_CALLBACK]
 F86  0D804                    TEST s8, 04[DMA_CH3_IRQ_MASK]      ;DMA Channel 3
 F87  3401A                    CALL NZ, 01A[DMA_CH3_CALLBACK]
 F88                           ; Check GPIO IRQ
 F88  0D840                    TEST s8, 40[GPIOA_IRQ_MASK]        ;GPIOA
 F89  3401B                    CALL NZ, 01B[GPIOA_CALLBACK]
 F8A  0D840                    TEST s8, 40[GPIOA_IRQ_MASK]        ;GPIOB
 F8B  3401B                    CALL NZ, 01B[GPIOA_CALLBACK]
 F8C                           ; Check RS232 IRQ
 F8C  0D810                    TEST s8, 10[TX_IRQ_MASK]           ;RS232 TX
 F8D  3401D                    CALL NZ, 01D[TX_CALLBACK]
 F8E  0D820                    TEST s8, 20[RX_IRQ_MASK]           ;RS232 RX
 F8F  34A80                    CALL NZ, A80[RX_CALLBACK]
 F90  01800                    LOAD s8, 00
 F91  2D800                    OUTPUT s8, 00[ISR_VECTOR]          ;Clean vector
 F92  29001                    RETURNI ENABLE


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

D:\OneDrive\Documentos\Universidad\LCSE\entregas\LCSE_PROJ\src\program\rom.psm



List of defined constants

 CONSTANT name      Value        Source PSM File

 timestamp_hours    19'd         
 timestamp_minutes  36'd         
 timestamp_seconds  22'd         
 datestamp_year     20'd         
 datestamp_month    11'd         
 datestamp_day      14'd         
 NUL                00           
 BEL                07           
 BS                 08           
 HT                 09           
 LF                 0A           
 VT                 0B           
 CR                 0D           
 ESC                1B           
 DEL                7F           
 DCS                90           
 ST                 9C           
 sRAM               10           rom.psm
 eRAM               1F           rom.psm
 DMA_MEM_BASE       C0           rom.psm
 DMA_CONF_CH1       C0           rom.psm
 DMA_SRC_CH1        C1           rom.psm
 DMA_DEST_CH1       C2           rom.psm
 DMA_CNT_CH1        C3           rom.psm
 DMA_CONF_CH2       C4           rom.psm
 DMA_SRC_CH2        C5           rom.psm
 DMA_DEST_CH2       C6           rom.psm
 DMA_CNT_CH2        C7           rom.psm
 DMA_CONF_CH3       C8           rom.psm
 DMA_SRC_CH3        C9           rom.psm
 DMA_DEST_CH3       CA           rom.psm
 DMA_CNT_CH3        CB           rom.psm
 RS232_BASE         D0           rom.psm
 RS232_CONF         D0           rom.psm
 RS232_STATUS       D1           rom.psm
 RS232_TX_DATA      D2           rom.psm
 RS232_RX_DAT       D3           rom.psm
 GPIO_BASE          E0           rom.psm
 GPIO_A             E0           rom.psm
 GPIO_MODEA_REG1    E1           rom.psm
 GPIO_MODEA_REG2    E2           rom.psm
 GPIO_AFMODEA_REG   E3           rom.psm
 GPIO_IRQA_MASK     E4           rom.psm
 GPIO_IRQMODEA_MASK E5           rom.psm
 GPIO_B             E6           rom.psm
 GPIO_MODEB_REG1    E7           rom.psm
 GPIO_MODEB_REG2    E8           rom.psm
 GPIO_AFMODEB_REG   E9           rom.psm
 GPIO_IRQB_MASK     EA           rom.psm
 GPIO_IRQMODEB_MASK EB           rom.psm
 DISPLAY_EN         D8           rom.psm
 DISPLAY_IEN        D9           rom.psm
 DISPLAY_01         DA           rom.psm
 DISPLAY_23         DB           rom.psm
 DISPLAY_45         DC           rom.psm
 DISPLAY_67         DD           rom.psm
 ISR_VECTOR         00           rom.psm
 DMA_CH1_IRQ_MASK   01           rom.psm
 DMA_CH2_IRQ_MASK   02           rom.psm
 DMA_CH3_IRQ_MASK   04           rom.psm
 TX_IRQ_MASK        10           rom.psm
 RX_IRQ_MASK        20           rom.psm
 GPIOA_IRQ_MASK     40           rom.psm
 GPIOB_IRQ_MASK     80           rom.psm
 ASCII_LF           0A           rom.psm
 ASCII_0            30           rom.psm
 ASCII_1            31           rom.psm
 ASCII_2            32           rom.psm
 ASCII_3            33           rom.psm
 ASCII_4            34           rom.psm
 ASCII_5            35           rom.psm
 ASCII_6            36           rom.psm
 ASCII_7            37           rom.psm
 ASCII_8            38           rom.psm
 ASCII_9            39           rom.psm
 ASCII_A            41           rom.psm
 ASCII_B            42           rom.psm
 ASCII_C            43           rom.psm
 ASCII_D            44           rom.psm
 ASCII_E            45           rom.psm
 ASCII_F            46           rom.psm
 ASCII_G            47           rom.psm
 ASCII_H            48           rom.psm
 ASCII_I            49           rom.psm
 ASCII_J            4A           rom.psm
 ASCII_K            4B           rom.psm
 ASCII_L            4C           rom.psm
 ASCII_M            4D           rom.psm
 ASCII_N            4E           rom.psm
 ASCII_O            4F           rom.psm
 ASCII_P            50           rom.psm
 ASCII_Q            51           rom.psm
 ASCII_R            52           rom.psm
 ASCII_S            53           rom.psm
 ASCII_T            54           rom.psm
 ASCII_U            55           rom.psm
 ASCII_V            56           rom.psm
 ASCII_W            57           rom.psm
 ASCII_X            58           rom.psm
 ASCII_Y            59           rom.psm
 ASCII_Z            5A           rom.psm
 RX_STORE_CNT       10           rom.psm
 RX_STORE_BASE      11           rom.psm
 DMA_STR_BASE       1A           rom.psm



No TABLEs defined



List of text strings

 STRING name       String              Source PSM File

 KCPSM6_version$   "v2.70"             
 datestamp$        "14 Nov 2020"       
 timestamp$        "19:36:22"          
 HEXAVAL$          "0123456789ABCDEF"  rom.psm
 SAYHELLOW$        "Hello World!"      rom.psm
 MERCADONA$        "Quiere bolsa?"     rom.psm
 NACK$             "ERROR!"            rom.psm
 ACK$              "OK!"               rom.psm



List of line labels

   Label              Addr  Source PSM File

 * start              000   rom.psm
   loop               00C   rom.psm
   DELAY_MS           00D   rom.psm
   DELAY_1MS          011   rom.psm
   DELAY_1MS_LOOP     013   rom.psm
   DMA_CH1_CALLBACK   018   rom.psm
   DMA_CH2_CALLBACK   019   rom.psm
   DMA_CH3_CALLBACK   01A   rom.psm
   GPIOA_CALLBACK     01B   rom.psm
 * GPIOB_CALLBACK     01C   rom.psm
   TX_CALLBACK        01D   rom.psm
   RX_CALLBACK        A80   rom.psm
   RX_INBOUND         A8B   rom.psm
   NEW_COMMAND        A8D   rom.psm
   GPIO_CMD           A96   rom.psm
   GPIO_GET_PIN       A9C   rom.psm
   GPIO_CALC_MASK     AA3   rom.psm
   GPIO_MASK_LOOP     AA6   rom.psm
   GPIO_CMD_SELECT    AAD   rom.psm
   GPIO_CONF_CMD      AB7   rom.psm
   GPIO_CONTINUE      ABD   rom.psm
   GPIO_CONF_OUT      ACB   rom.psm
   GPIO_CONF_IN       B80   rom.psm
   GPIO_CONF_OR       B89   rom.psm
   GPIO_CONF_OF       B9A   rom.psm
   GPIO_CONF_AFI      BAA   rom.psm
   GPIO_CONF_AFO      BB4   rom.psm
   GPIO_CONF_PIN      BBD   rom.psm
   GPIO_SET_CMD       BC5   rom.psm
   GPIO_RESET_CMD     BC9   rom.psm
   TEMP_CMD           BCE   rom.psm
   GET_TEMP_CMD       BD4   rom.psm
   SET_TEMP_CMD       BE8   rom.psm
   SET_TEMP_CONT1     BEF   rom.psm
   SET_TEMP_CONT2     BF6   rom.psm
   REG_CMD            C02   rom.psm
   GET_REG_CMD        C09   rom.psm
   SET_REG_CMD        C31   rom.psm
   ERROR_CMD          C56   rom.psm
   OK_CMD             C5B   rom.psm
   CLC_CMD            C60   rom.psm
   LOOP_CMD_CLC       C63   rom.psm
 * hellow             C69   rom.psm
 * cajero             C76   rom.psm
   hexv               C84   rom.psm
   okmsg              C95   rom.psm
   errormsg           C99   rom.psm
   DMA_TX_STR         CA0   rom.psm
   DMA_TX_STR_LOOP    CA2   rom.psm
   DMA_TX_LOAD        CAC   rom.psm
   HEX2DEC            CBA   rom.psm
   HEXCMP             CBD   rom.psm
   HEX_VAL_ERROR      CC6   rom.psm
   HEXVAL_RETURN      CC7   rom.psm
   DEC2HEX            CC8   rom.psm
   DEC2HEX_C          CCD   rom.psm
   WAIT_DMA_CH1       CD1   rom.psm
 * ISR                F80   rom.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             65
 STAR              -

 AND              17
 OR               11
 XOR              17

 ADD              38
 ADDCY             4
 SUB               7
 SUBCY             -

 TEST              8
 TESTCY            -
 COMPARE          35
 COMPARECY         -

 SL0              16
 SL1               -
 SLX               -
 SLA               -
 RL                3
 SR0               8
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT            33
 OUTPUT           38
 OUTPUTK           -

 STORE             -
 FETCH             -

 DISABLE           1
 ENABLE            1
 RETURNI           1

 JUMP             67
 JUMP@             -
 CALL             24
 CALL@             3
 RETURN           15
 LOAD&RETURN      55

 HWBUILD           -



End of KCPSM6 log file.

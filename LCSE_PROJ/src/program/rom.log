KCPSM6 Assembler log file for program 'D:\OneDrive\Documentos\Universidad\LCSE\entregas\LCSE_PROJ\src\program\rom.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 13 Nov 2020
Assembly timestamp: 10:37:07

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: F92 hex
Nominal program memory size: 4K (4096)   address(11:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 334
Memory locations available: 3762


Assembly listing

 Addr Code                     Instruction

 000                           ; LCSE picoblaze test program
 000                           ;Memory Map definition
 000                           CONSTANT sRAM, 10                     ; RAM Start address
 000                           CONSTANT eRAM, 1F                     ; RAM end address
 000                           CONSTANT DMA_MEM_BASE, C0             ;
 000                           CONSTANT DMA_CONF_CH1, C0             ;
 000                           CONSTANT DMA_SRC_CH1, C1              ;
 000                           CONSTANT DMA_DEST_CH1, C2             ;
 000                           CONSTANT DMA_CNT_CH1, C3              ;
 000                           CONSTANT DMA_CONF_CH2, C4             ;
 000                           CONSTANT DMA_SRC_CH2, C5              ;
 000                           CONSTANT DMA_DEST_CH2, C6             ;
 000                           CONSTANT DMA_CNT_CH2, C7              ;
 000                           CONSTANT DMA_CONF_CH3, C8             ;
 000                           CONSTANT DMA_SRC_CH3, C9              ;
 000                           CONSTANT DMA_DEST_CH3, CA             ;
 000                           CONSTANT DMA_CNT_CH3, CB              ;
 000                           CONSTANT RS232_BASE, D0               ;
 000                           CONSTANT RS232_CONF, D0               ;
 000                           CONSTANT RS232_STATUS, D1             ;
 000                           CONSTANT RS232_TX_DATA, D2            ;
 000                           CONSTANT RS232_RX_DAT, D3             ;
 000                           CONSTANT GPIO_BASE, E0                ;
 000                           CONSTANT GPIO_IRQA_MASK, E0           ;
 000                           CONSTANT GPIO_IRQB_MASK, E1           ;
 000                           CONSTANT GPIO_IRQMODEA_MASK, E2       ;
 000                           CONSTANT GPIO_IRQMODEB_MASK, E3       ;
 000                           CONSTANT GPIO_MODEA_REG1, E4          ;
 000                           CONSTANT GPIO_MODEA_REG2, E5          ;
 000                           CONSTANT GPIO_MODEB_REG1, E6          ;
 000                           CONSTANT GPIO_MODEB_REG2, E7          ;
 000                           CONSTANT GPIO_AFMODEA_REG, E8
 000                           CONSTANT GPIO_AFMODEB_REG, E9
 000                           CONSTANT GPIO_A, EA                   ;
 000                           CONSTANT GPIO_B, EB                   ;
 000                           CONSTANT ISR_VECTOR, 00               ;
 000                           CONSTANT DMA_CH1_IRQ_MASK, 01
 000                           CONSTANT DMA_CH2_IRQ_MASK, 02
 000                           CONSTANT DMA_CH3_IRQ_MASK, 04
 000                           CONSTANT TX_IRQ_MASK, 10
 000                           CONSTANT RX_IRQ_MASK, 20
 000                           CONSTANT GPIOA_IRQ_MASK, 40
 000                           CONSTANT GPIOB_IRQ_MASK, 80
 000                           ; COMMADS -> ASCII to hex
 000                           CONSTANT ASCII_LF, 0A
 000                           CONSTANT ASCII_0, 30
 000                           CONSTANT ASCII_1, 31
 000                           CONSTANT ASCII_2, 32
 000                           CONSTANT ASCII_3, 33
 000                           CONSTANT ASCII_4, 34
 000                           CONSTANT ASCII_5, 35
 000                           CONSTANT ASCII_6, 36
 000                           CONSTANT ASCII_7, 37
 000                           CONSTANT ASCII_8, 38
 000                           CONSTANT ASCII_9, 39
 000                           CONSTANT ASCII_A, 41
 000                           CONSTANT ASCII_B, 42
 000                           CONSTANT ASCII_C, 43
 000                           CONSTANT ASCII_D, 44
 000                           CONSTANT ASCII_E, 45
 000                           CONSTANT ASCII_F, 46
 000                           CONSTANT ASCII_G, 47
 000                           CONSTANT ASCII_H, 48
 000                           CONSTANT ASCII_I, 49
 000                           CONSTANT ASCII_J, 4A
 000                           CONSTANT ASCII_K, 4B
 000                           CONSTANT ASCII_L, 4C
 000                           CONSTANT ASCII_M, 4D
 000                           CONSTANT ASCII_N, 4E
 000                           CONSTANT ASCII_O, 4F
 000                           CONSTANT ASCII_P, 50
 000                           CONSTANT ASCII_Q, 51
 000                           CONSTANT ASCII_R, 52
 000                           CONSTANT ASCII_S, 53
 000                           CONSTANT ASCII_T, 54
 000                           CONSTANT ASCII_U, 55
 000                           CONSTANT ASCII_V, 56
 000                           CONSTANT ASCII_W, 57
 000                           CONSTANT ASCII_X, 58
 000                           CONSTANT ASCII_Y, 59
 000                           CONSTANT ASCII_Z, 5A
 000                           STRING HEXAVAL$, "0123456789ABCDEF"
 000                           STRING SAYHELLOW$, "Hello World!"
 000                           STRING MERCADONA$, "Quiere bolsa?"
 000                           ; Static memory pointers
 000                           CONSTANT RX_STORE_CNT, 10
 000                           CONSTANT RX_STORE_BASE, 11
 000                           CONSTANT DMA_STR_BASE, 1A
 000                    start: 
 000  01000                    LOAD s0, 00
 001  2D010                    OUTPUT s0, 10[RX_STORE_CNT]
 002  2D011                    OUTPUT s0, 11[RX_STORE_BASE]
 003  01082                    LOAD s0, 82
 004  2D0D0                    OUTPUT s0, D0[RS232_CONF]
 005  0100C                    LOAD s0, 0C                           ;
 006  2D0E5                    OUTPUT s0, E5[GPIO_MODEA_REG2]
 007  01002                    LOAD s0, 02
 008  2D0E8                    OUTPUT s0, E8[GPIO_AFMODEA_REG]
 009  28001                    ENABLE INTERRUPT
 00A  2200A              loop: JUMP 00A[loop]
 00B              DMA_TX_TEST: 
 00B  01B0B                    LOAD sB, 0B[cajero'upper]
 00C  01AD8                    LOAD sA, D8[cajero'lower]
 00D  20BF7                    CALL BF7[DMA_TX_STR]
 00E  25000                    RETURN 
 00F                  RX_TEST: 
 00F  28001                    ENABLE INTERRUPT
 010  01120                    LOAD s1, 20[RX_IRQ_MASK]
 011  01000                    LOAD s0, 00
 012  2D010                    OUTPUT s0, 10[RX_STORE_CNT]
 013  2D011                    OUTPUT s0, 11[RX_STORE_BASE]
 014  01047                    LOAD s0, 47[ASCII_G]
 015  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 016  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 017  01700                    LOAD s7, 00
 018  01700                    LOAD s7, 00
 019  01043                    LOAD s0, 43[ASCII_C]
 01A  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 01B  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 01C  01700                    LOAD s7, 00
 01D  01700                    LOAD s7, 00
 01E  01041                    LOAD s0, 41[ASCII_A]
 01F  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 020  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 021  01700                    LOAD s7, 00
 022  01700                    LOAD s7, 00
 023  01035                    LOAD s0, 35
 024  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 025  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 026  01700                    LOAD s7, 00
 027  01700                    LOAD s7, 00
 028  01030                    LOAD s0, 30
 029  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 02A  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 02B  01700                    LOAD s7, 00
 02C  01700                    LOAD s7, 00
 02D  0100A                    LOAD s0, 0A[ASCII_LF]
 02E  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 02F  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 030  01700                    LOAD s7, 00
 031  01700                    LOAD s7, 00
 032  01047                    LOAD s0, 47[ASCII_G]
 033  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 034  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 035  01700                    LOAD s7, 00
 036  01700                    LOAD s7, 00
 037  01053                    LOAD s0, 53[ASCII_S]
 038  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 039  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 03A  01700                    LOAD s7, 00
 03B  01700                    LOAD s7, 00
 03C  01041                    LOAD s0, 41[ASCII_A]
 03D  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 03E  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 03F  01700                    LOAD s7, 00
 040  01700                    LOAD s7, 00
 041  01035                    LOAD s0, 35
 042  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 043  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 044  01700                    LOAD s7, 00
 045  01700                    LOAD s7, 00
 046  01030                    LOAD s0, 30
 047  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 048  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 049  01700                    LOAD s7, 00
 04A  01700                    LOAD s7, 00
 04B  0100A                    LOAD s0, 0A[ASCII_LF]
 04C  2D0D3                    OUTPUT s0, D3[RS232_RX_DAT]
 04D  2D100                    OUTPUT s1, 00[ISR_VECTOR]
 04E  25000                    RETURN 
 04F             DEFAULT_TEST: 
 04F  010A1                    LOAD s0, A1
 050  01110                    LOAD s1, 10[sRAM]
 051  2C010                    OUTPUT s0, (s1)
 052  11101                    ADD s1, 01
 053  010A2                    LOAD s0, A2
 054  2C010                    OUTPUT s0, (s1)
 055  11101                    ADD s1, 01
 056  010A3                    LOAD s0, A3
 057  2C010                    OUTPUT s0, (s1)
 058  11101                    ADD s1, 01
 059  01055                    LOAD s0, 55                           ;
 05A  2D0E4                    OUTPUT s0, E4[GPIO_MODEA_REG1]
 05B  0105F                    LOAD s0, 5F                           ;
 05C  2D0E5                    OUTPUT s0, E5[GPIO_MODEA_REG2]
 05D  01002                    LOAD s0, 02
 05E  2D0E8                    OUTPUT s0, E8[GPIO_AFMODEA_REG]
 05F  010A0                    LOAD s0, A0
 060  2D0E6                    OUTPUT s0, E6[GPIO_MODEB_REG1]
 061  01080                    LOAD s0, 80
 062  2D0E3                    OUTPUT s0, E3[GPIO_IRQMODEB_MASK]
 063  2D0E1                    OUTPUT s0, E1[GPIO_IRQB_MASK]
 064  010FF                    LOAD s0, FF
 065  2D0EA                    OUTPUT s0, EA[GPIO_A]
 066  010D2                    LOAD s0, D2[RS232_TX_DATA]
 067  2D0C2                    OUTPUT s0, C2[DMA_DEST_CH1]
 068  01010                    LOAD s0, 10[sRAM]
 069  2D0C1                    OUTPUT s0, C1[DMA_SRC_CH1]
 06A  01012                    LOAD s0, 12
 06B  2D0C3                    OUTPUT s0, C3[DMA_CNT_CH1]
 06C  010A0                    LOAD s0, A0
 06D  2D0C0                    OUTPUT s0, C0[DMA_CONF_CH1]
 06E  09010                    INPUT s0, 10[sRAM]
 06F  2D0D2                    OUTPUT s0, D2[RS232_TX_DATA]
 070  010CF                    LOAD s0, CF
 071  2D0D0                    OUTPUT s0, D0[RS232_CONF]
 072  01800                    LOAD s8, 00
 073  2D800                    OUTPUT s8, 00[ISR_VECTOR]
 074  28001                    ENABLE INTERRUPT
 075  25000                    RETURN 
 076                 DELAY_MS: 
 076  2007A                    CALL 07A[DELAY_1MS]
 077  19001                    SUB s0, 01
 078  36076                    JUMP NZ, 076[DELAY_MS]
 079  25000                    RETURN 
 07A                DELAY_1MS: 
 07A  01800                    LOAD s8, 00
 07B  01900                    LOAD s9, 00
 07C           DELAY_1MS_LOOP: 
 07C  11808                    ADD s8, 08
 07D  13900                    ADDCY s9, 00
 07E  1D94E                    COMPARE s9, 4E
 07F  3A07C                    JUMP C, 07C[DELAY_1MS_LOOP]
 080  25000                    RETURN 
 081         DMA_CH1_CALLBACK: 
 081  25000                    RETURN 
 082         DMA_CH2_CALLBACK: 
 082  25000                    RETURN 
 083         DMA_CH3_CALLBACK: 
 083  25000                    RETURN 
 084           GPIOA_CALLBACK: 
 084  25000                    RETURN 
 085           GPIOB_CALLBACK: 
 085  25000                    RETURN 
 086              TX_CALLBACK: 
 086  25000                    RETURN 
 A80                           ADDRESS A80
 A80              RX_CALLBACK: 
 A80  099D3                    INPUT s9, D3[RS232_RX_DAT]            ;> Load RX data
 A81  1D90A                    COMPARE s9, 0A[ASCII_LF]              ;> Check end of line
 A82  32B80                    JUMP Z, B80[NEW_COMMAND]
 A83  09A10                    INPUT sA, 10[RX_STORE_CNT]            ;> Load mem counter
 A84  00BA0                    LOAD sB, sA
 A85  11B11                    ADD sB, 11[RX_STORE_BASE]             ;> Calc save address
 A86  2C9B0                    OUTPUT s9, (sB)                       ;> Store new value
 A87  11A01                    ADD sA, 01                            ;> Increment counter
 A88                           ; Avoid memory overflow
 A88  1DA06                    COMPARE sA, 06                        ;> Compare counter with max value
 A89  3AA8B                    JUMP C, A8B[RX_INBOUND]
 A8A  19A01                    SUB sA, 01                            ;> if greater, return to previus value
 A8B               RX_INBOUND: 
 A8B  2DA10                    OUTPUT sA, 10[RX_STORE_CNT]           ;> Store count value
 A8C  25000                    RETURN                                ;> Return
 A8D                           ; After a LF character, the command is procesed
 B80                           ADDRESS B80
 B80              NEW_COMMAND: 
 B80                           ; Some sintax sugar
 B80                           NAMEREG s9, cmdDir
 B80                           NAMEREG sA, cmd
 B80                           NAMEREG sB, pinN
 B80                           NAMEREG sC, modeMask
 B80                           NAMEREG sD, pinMask
 B80                           NAMEREG sE, ModeReg
 B80                           NAMEREG sF, gpioPort
 B80                           ; Get the first command character
 B80  01911                    LOAD s9[cmdDir], 11[RX_STORE_BASE]    ;> Store input value pointer
 B81  08A90                    INPUT sA[cmd], (s9[cmdDir])           ;> Load first input value
 B82  1DA47                    COMPARE sA[cmd], 47[ASCII_G]          ;> Look for GPIO command
 B83  32B89                    JUMP Z, B89[GPIO_CMD]
 B84  1DA54                    COMPARE sA[cmd], 54[ASCII_T]          ;> Look for TEMP command
 B85  32BC0                    JUMP Z, BC0[TEMP_CMD]
 B86  1DA52                    COMPARE sA[cmd], 52[ASCII_R]          ;> Look for REGISTER command
 B87  32BC1                    JUMP Z, BC1[REG_CMD]
 B88  22BC2                    JUMP BC2[CLC_CMD]                     ;> If no matching commad, clear registers
 B89                           ; When GPIO command
 B89                 GPIO_CMD: 
 B89  11902                    ADD s9[cmdDir], 02                    ;> Increment pointer
 B8A  08A90                    INPUT sA[cmd], (s9[cmdDir])           ;> Get port
 B8B  01FEA                    LOAD sF[gpioPort], EA[GPIO_A]         ;> Load GPIOA as default
 B8C  01EE5                    LOAD sE[ModeReg], E5[GPIO_MODEA_REG2] ;>
 B8D  1DA41                    COMPARE sA[cmd], 41[ASCII_A]          ;> Check if GPIOA
 B8E  32B91                    JUMP Z, B91[GPIO_GET_PIN]             ;> If correct, continue
 B8F  01FEB                    LOAD sF[gpioPort], EB[GPIO_B]         ;> If no GPIOA, change to GPIOB
 B90  01EE7                    LOAD sE[ModeReg], E7[GPIO_MODEB_REG2] ;>
 B91                           ; Calculate PIN and registers
 B91             GPIO_GET_PIN: 
 B91  11901                    ADD s9[cmdDir], 01                    ;> Increment pointer
 B92  08B90                    INPUT sB[pinN], (s9[cmdDir])          ;> Load pin value
 B93  19B30                    SUB sB[pinN], 30                      ;> Convert to ASCII to DEC
 B94  3ABC2                    JUMP C, BC2[CLC_CMD]                  ;> Check underflow. If true, the value is invalid so,
 B95                           ;> go to clean registers. (FAIL)
 B95  1DB04                    COMPARE sB[pinN], 04                  ;> Check if pin number is below 4 to select correct registers
 B96  3AB9B                    JUMP C, B9B[GPIO_CALC_MASK]           ;> if less than, continue
 B97  19E01                    SUB sE[ModeReg], 01                   ;> And update mode register
 B98  1DB08                    COMPARE sB[pinN], 08                  ;> Check if pin below 8 (MAX PIN)
 B99  3AB9B                    JUMP C, B9B[GPIO_CALC_MASK]           ;> if less than, continue
 B9A  22BC2                    JUMP BC2[CLC_CMD]                     ;> if greater/equal, the values is invalid (FAIL)
 B9B                           ; Calculate PIN MASK and MODE MASK
 B9B           GPIO_CALC_MASK: 
 B9B  11901                    ADD s9[cmdDir], 01                    ;> Increment pointer
 B9C  08A90                    INPUT sA[cmd], (s9[cmdDir])           ;> get Mode value
 B9D  01D01                    LOAD sD[pinMask], 01                  ;> Set deault pin mask (PIN0)
 B9E  01C01                    LOAD sC[modeMask], 01                 ;> Set default mode mask (INPUT)
 B9F                           ;TODO: Change to ASCII?
 B9F  03A01                    AND sA[cmd], 01                       ;> Check mode
 BA0  32BA2                    JUMP Z, BA2[GPIO_MASK_LOOP]           ;> if input, continue
 BA1  01C02                    LOAD sC[modeMask], 02                 ;> else, change to OUPUT and continue
 BA2           GPIO_MASK_LOOP: 
 BA2  1DB00                    COMPARE sB[pinN], 00                  ;> check pin counter equal 0
 BA3  32BA9                    JUMP Z, BA9[GPIO_CMD_SELECT]          ;> if true, continue
 BA4  14C02                    RL sC[modeMask]                       ;> Rotate left two positions mode mask
 BA5  14C02                    RL sC[modeMask]                       ;>
 BA6  14D02                    RL sD[pinMask]                        ;> Rotate left one position pin
 BA7  19B01                    SUB sB[pinN], 01                      ;> Decrement pin counter
 BA8  22BA2                    JUMP BA2[GPIO_MASK_LOOP]
 BA9                           ; Check command type
 BA9          GPIO_CMD_SELECT: 
 BA9  01911                    LOAD s9[cmdDir], 11[RX_STORE_BASE]    ;> Load base pointer
 BAA  11901                    ADD s9[cmdDir], 01                    ;> Increment pointer one position
 BAB  08A90                    INPUT sA[cmd], (s9[cmdDir])           ;> Read command character
 BAC  1DA43                    COMPARE sA[cmd], 43[ASCII_C]          ;> Check configurarion command
 BAD  32BB3                    JUMP Z, BB3[GPIO_CONF_CMD]
 BAE  1DA53                    COMPARE sA[cmd], 53[ASCII_S]          ;> Check set command
 BAF  32BB7                    JUMP Z, BB7[GPIO_SET_CMD]
 BB0  1DA52                    COMPARE sA[cmd], 52[ASCII_R]          ;> Check reset command
 BB1  32BBB                    JUMP Z, BBB[GPIO_RESET_CMD]
 BB2  22BC2                    JUMP BC2[CLC_CMD]
 BB3                           ; When configuration command
 BB3            GPIO_CONF_CMD: 
 BB3  088E0                    INPUT s8, (sE[ModeReg])               ;> Get current mode reg
 BB4  048C0                    OR s8, sC[modeMask]                   ;> Update mode reg
 BB5  2C8E0                    OUTPUT s8, (sE[ModeReg])              ;> Set mode reg
 BB6  22BC2                    JUMP BC2[CLC_CMD]                     ;> Clean data
 BB7             GPIO_SET_CMD: 
 BB7  088F0                    INPUT s8, (sF[gpioPort])              ;> Get current GPIO reg
 BB8  048D0                    OR s8, sD[pinMask]                    ;> Update GPIO reg
 BB9  2C8F0                    OUTPUT s8, (sF[gpioPort])             ;> set new GPIO reg
 BBA  22BC2                    JUMP BC2[CLC_CMD]                     ;> Clean data
 BBB           GPIO_RESET_CMD: 
 BBB  088F0                    INPUT s8, (sF[gpioPort])              ;> Get current GPIO reg
 BBC  07DFF                    XOR sD[pinMask], FF                   ;> Update GPIO reg. (NOT is not implemented so, we use XOR)
 BBD  028D0                    AND s8, sD[pinMask]                   ;> Clean bit
 BBE  2C8F0                    OUTPUT s8, (sF[gpioPort])             ;> Set new GPIO reg
 BBF  22BC2                    JUMP BC2[CLC_CMD]                     ;> Clean data
 BC0                 TEMP_CMD: 
 BC0  22BC2                    JUMP BC2[CLC_CMD]                     ;> Clean data
 BC1                  REG_CMD: 
 BC1  22BC2                    JUMP BC2[CLC_CMD]                     ;> Clean data
 BC2                           ; Clean
 BC2                  CLC_CMD: 
 BC2                           ; Restore register names
 BC2                           NAMEREG cmdDir, s9
 BC2                           NAMEREG cmd, sA
 BC2                           NAMEREG pinN, sB
 BC2                           NAMEREG modeMask, sC
 BC2                           NAMEREG pinMask, sD
 BC2                           NAMEREG ModeReg, sE
 BC2                           NAMEREG gpioPort, sF
 BC2  09B10                    INPUT sB, 10[RX_STORE_CNT]            ;> Get counter
 BC3  01C00                    LOAD sC, 00                           ;> Set 0 value
 BC4  2DC10                    OUTPUT sC, 10[RX_STORE_CNT]
 BC5             LOOP_CMD_CLC: 
 BC5  01A11                    LOAD sA, 11[RX_STORE_BASE]            ;> Load base register
 BC6  10AB0                    ADD sA, sB                            ;> Set address
 BC7  2CCA0                    OUTPUT sC, (sA)                       ;> Clean register
 BC8  19B01                    SUB sB, 01                            ;> decrement counter
 BC9  36BC5                    JUMP NZ, BC5[LOOP_CMD_CLC]            ;> While not 0
 BCA  25000                    RETURN 
 BCB  21148            hellow: LOAD&RETURN s1, 48[SAYHELLOW$:"H"]
 BCC  21165                    LOAD&RETURN s1, 65[SAYHELLOW$:"e"]
 BCD  2116C                    LOAD&RETURN s1, 6C[SAYHELLOW$:"l"]
 BCE  2116C                    LOAD&RETURN s1, 6C[SAYHELLOW$:"l"]
 BCF  2116F                    LOAD&RETURN s1, 6F[SAYHELLOW$:"o"]
 BD0  21120                    LOAD&RETURN s1, 20[SAYHELLOW$:" "]
 BD1  21157                    LOAD&RETURN s1, 57[SAYHELLOW$:"W"]
 BD2  2116F                    LOAD&RETURN s1, 6F[SAYHELLOW$:"o"]
 BD3  21172                    LOAD&RETURN s1, 72[SAYHELLOW$:"r"]
 BD4  2116C                    LOAD&RETURN s1, 6C[SAYHELLOW$:"l"]
 BD5  21164                    LOAD&RETURN s1, 64[SAYHELLOW$:"d"]
 BD6  21121                    LOAD&RETURN s1, 21[SAYHELLOW$:"!"]
 BD7  2110A                    LOAD&RETURN s1, 0A[ASCII_LF]
 BD8  21151            cajero: LOAD&RETURN s1, 51[MERCADONA$:"Q"]
 BD9  21175                    LOAD&RETURN s1, 75[MERCADONA$:"u"]
 BDA  21169                    LOAD&RETURN s1, 69[MERCADONA$:"i"]
 BDB  21165                    LOAD&RETURN s1, 65[MERCADONA$:"e"]
 BDC  21172                    LOAD&RETURN s1, 72[MERCADONA$:"r"]
 BDD  21165                    LOAD&RETURN s1, 65[MERCADONA$:"e"]
 BDE  21120                    LOAD&RETURN s1, 20[MERCADONA$:" "]
 BDF  21162                    LOAD&RETURN s1, 62[MERCADONA$:"b"]
 BE0  2116F                    LOAD&RETURN s1, 6F[MERCADONA$:"o"]
 BE1  2116C                    LOAD&RETURN s1, 6C[MERCADONA$:"l"]
 BE2  21173                    LOAD&RETURN s1, 73[MERCADONA$:"s"]
 BE3  21161                    LOAD&RETURN s1, 61[MERCADONA$:"a"]
 BE4  2113F                    LOAD&RETURN s1, 3F[MERCADONA$:"?"]
 BE5  2110A                    LOAD&RETURN s1, 0A[ASCII_LF]
 BE6  21130              hexv: LOAD&RETURN s1, 30[HEXAVAL$:"0"]
 BE7  21131                    LOAD&RETURN s1, 31[HEXAVAL$:"1"]
 BE8  21132                    LOAD&RETURN s1, 32[HEXAVAL$:"2"]
 BE9  21133                    LOAD&RETURN s1, 33[HEXAVAL$:"3"]
 BEA  21134                    LOAD&RETURN s1, 34[HEXAVAL$:"4"]
 BEB  21135                    LOAD&RETURN s1, 35[HEXAVAL$:"5"]
 BEC  21136                    LOAD&RETURN s1, 36[HEXAVAL$:"6"]
 BED  21137                    LOAD&RETURN s1, 37[HEXAVAL$:"7"]
 BEE  21138                    LOAD&RETURN s1, 38[HEXAVAL$:"8"]
 BEF  21139                    LOAD&RETURN s1, 39[HEXAVAL$:"9"]
 BF0  21141                    LOAD&RETURN s1, 41[HEXAVAL$:"A"]
 BF1  21142                    LOAD&RETURN s1, 42[HEXAVAL$:"B"]
 BF2  21143                    LOAD&RETURN s1, 43[HEXAVAL$:"C"]
 BF3  21144                    LOAD&RETURN s1, 44[HEXAVAL$:"D"]
 BF4  21145                    LOAD&RETURN s1, 45[HEXAVAL$:"E"]
 BF5  21146                    LOAD&RETURN s1, 46[HEXAVAL$:"F"]
 BF6  2110D                    LOAD&RETURN s1, 0D
 BF7                           ;LOAD sA and sB with the string load address
 BF7               DMA_TX_STR: 
 BF7  01000                    LOAD s0, 00
 BF8  0121A                    LOAD s2, 1A[DMA_STR_BASE]
 BF9          DMA_TX_STR_LOOP: 
 BF9  24BA0                    CALL@ (sB, sA)
 BFA  0121A                    LOAD s2, 1A[DMA_STR_BASE]
 BFB  10200                    ADD s2, s0
 BFC  2C120                    OUTPUT s1, (s2)
 BFD  1D10A                    COMPARE s1, 0A[ASCII_LF]
 BFE  32C03                    JUMP Z, C03[DMA_TX_LOAD]
 BFF  11001                    ADD s0, 01
 C00  11A01                    ADD sA, 01
 C01  13B00                    ADDCY sB, 00
 C02  22BF9                    JUMP BF9[DMA_TX_STR_LOOP]
 C03              DMA_TX_LOAD: 
 C03  011D2                    LOAD s1, D2[RS232_TX_DATA]
 C04  2D1C2                    OUTPUT s1, C2[DMA_DEST_CH1]
 C05  0111A                    LOAD s1, 1A[DMA_STR_BASE]
 C06  2D1C1                    OUTPUT s1, C1[DMA_SRC_CH1]
 C07  0300F                    AND s0, 0F
 C08  05010                    OR s0, 10
 C09  2D0C3                    OUTPUT s0, C3[DMA_CNT_CH1]
 C0A  010A0                    LOAD s0, A0
 C0B  2D0C0                    OUTPUT s0, C0[DMA_CONF_CH1]
 C0C  0901A                    INPUT s0, 1A[DMA_STR_BASE]
 C0D  2D0D2                    OUTPUT s0, D2[RS232_TX_DATA]
 C0E  010CF                    LOAD s0, CF
 C0F  2D0D0                    OUTPUT s0, D0[RS232_CONF]
 C10  25000                    RETURN 
 C11                  HEX2DEC: 
 C11  01B0B                    LOAD sB, 0B[hexv'upper]
 C12  01AE6                    LOAD sA, E6[hexv'lower]
 C13  01F00                    LOAD sF, 00
 C14                   HEXCMP: 
 C14  24BA0                    CALL@ (sB, sA)
 C15  1C100                    COMPARE s1, s0
 C16  32C1D                    JUMP Z, C1D[HEXVAL_RETURN]
 C17  11A01                    ADD sA, 01
 C18  13B00                    ADDCY sB, 00
 C19  11F01                    ADD sF, 01
 C1A  1D1D0                    COMPARE s1, D0
 C1B  32C1D                    JUMP Z, C1D[HEXVAL_RETURN]
 C1C  22C14                    JUMP C14[HEXCMP]
 C1D            HEXVAL_RETURN: 
 C1D  25000                    RETURN 
 C1E                  DEC2HEX: 
 C1E  01B0B                    LOAD sB, 0B[hexv'upper]
 C1F  01AE6                    LOAD sA, E6[hexv'lower]
 C20  1D010                    COMPARE s0, 10
 C21  3AC23                    JUMP C, C23[DEC2HEX_C]
 C22  25000                    RETURN 
 C23                DEC2HEX_C: 
 C23  10A00                    ADD sA, s0
 C24  13B00                    ADDCY sB, 00
 C25  24BA0                    CALL@ (sB, sA)
 C26  25000                    RETURN 
 F80                           ADDRESS F80
 F80                      ISR: 
 F80  28000                    DISABLE INTERRUPT
 F81  09800                    INPUT s8, 00[ISR_VECTOR]              ;Read ISR vector
 F82                           ; Check DMA IRQ
 F82  0D801                    TEST s8, 01[DMA_CH1_IRQ_MASK]         ;DMA Channel 1
 F83  34081                    CALL NZ, 081[DMA_CH1_CALLBACK]
 F84  0D802                    TEST s8, 02[DMA_CH2_IRQ_MASK]         ;DMA Channel 2
 F85  34082                    CALL NZ, 082[DMA_CH2_CALLBACK]
 F86  0D804                    TEST s8, 04[DMA_CH3_IRQ_MASK]         ;DMA Channel 3
 F87  34083                    CALL NZ, 083[DMA_CH3_CALLBACK]
 F88                           ; Check GPIO IRQ
 F88  0D840                    TEST s8, 40[GPIOA_IRQ_MASK]           ;GPIOA
 F89  34084                    CALL NZ, 084[GPIOA_CALLBACK]
 F8A  0D840                    TEST s8, 40[GPIOA_IRQ_MASK]           ;GPIOB
 F8B  34084                    CALL NZ, 084[GPIOA_CALLBACK]
 F8C                           ; Check RS232 IRQ
 F8C  0D810                    TEST s8, 10[TX_IRQ_MASK]              ;RS232 TX
 F8D  34086                    CALL NZ, 086[TX_CALLBACK]
 F8E  0D820                    TEST s8, 20[RX_IRQ_MASK]              ;RS232 RX
 F8F  34A80                    CALL NZ, A80[RX_CALLBACK]
 F90  01800                    LOAD s8, 00
 F91  2D800                    OUTPUT s8, 00[ISR_VECTOR]             ;Clean vector
 F92  29001                    RETURNI ENABLE


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

D:\OneDrive\Documentos\Universidad\LCSE\entregas\LCSE_PROJ\src\program\rom.psm



List of defined constants

 CONSTANT name      Value        Source PSM File

 timestamp_hours    10'd         
 timestamp_minutes  37'd         
 timestamp_seconds  07'd         
 datestamp_year     20'd         
 datestamp_month    11'd         
 datestamp_day      13'd         
 NUL                00           
 BEL                07           
 BS                 08           
 HT                 09           
 LF                 0A           
 VT                 0B           
 CR                 0D           
 ESC                1B           
 DEL                7F           
 DCS                90           
 ST                 9C           
 sRAM               10           rom.psm
 eRAM               1F           rom.psm
 DMA_MEM_BASE       C0           rom.psm
 DMA_CONF_CH1       C0           rom.psm
 DMA_SRC_CH1        C1           rom.psm
 DMA_DEST_CH1       C2           rom.psm
 DMA_CNT_CH1        C3           rom.psm
 DMA_CONF_CH2       C4           rom.psm
 DMA_SRC_CH2        C5           rom.psm
 DMA_DEST_CH2       C6           rom.psm
 DMA_CNT_CH2        C7           rom.psm
 DMA_CONF_CH3       C8           rom.psm
 DMA_SRC_CH3        C9           rom.psm
 DMA_DEST_CH3       CA           rom.psm
 DMA_CNT_CH3        CB           rom.psm
 RS232_BASE         D0           rom.psm
 RS232_CONF         D0           rom.psm
 RS232_STATUS       D1           rom.psm
 RS232_TX_DATA      D2           rom.psm
 RS232_RX_DAT       D3           rom.psm
 GPIO_BASE          E0           rom.psm
 GPIO_IRQA_MASK     E0           rom.psm
 GPIO_IRQB_MASK     E1           rom.psm
 GPIO_IRQMODEA_MASK E2           rom.psm
 GPIO_IRQMODEB_MASK E3           rom.psm
 GPIO_MODEA_REG1    E4           rom.psm
 GPIO_MODEA_REG2    E5           rom.psm
 GPIO_MODEB_REG1    E6           rom.psm
 GPIO_MODEB_REG2    E7           rom.psm
 GPIO_AFMODEA_REG   E8           rom.psm
 GPIO_AFMODEB_REG   E9           rom.psm
 GPIO_A             EA           rom.psm
 GPIO_B             EB           rom.psm
 ISR_VECTOR         00           rom.psm
 DMA_CH1_IRQ_MASK   01           rom.psm
 DMA_CH2_IRQ_MASK   02           rom.psm
 DMA_CH3_IRQ_MASK   04           rom.psm
 TX_IRQ_MASK        10           rom.psm
 RX_IRQ_MASK        20           rom.psm
 GPIOA_IRQ_MASK     40           rom.psm
 GPIOB_IRQ_MASK     80           rom.psm
 ASCII_LF           0A           rom.psm
 ASCII_0            30           rom.psm
 ASCII_1            31           rom.psm
 ASCII_2            32           rom.psm
 ASCII_3            33           rom.psm
 ASCII_4            34           rom.psm
 ASCII_5            35           rom.psm
 ASCII_6            36           rom.psm
 ASCII_7            37           rom.psm
 ASCII_8            38           rom.psm
 ASCII_9            39           rom.psm
 ASCII_A            41           rom.psm
 ASCII_B            42           rom.psm
 ASCII_C            43           rom.psm
 ASCII_D            44           rom.psm
 ASCII_E            45           rom.psm
 ASCII_F            46           rom.psm
 ASCII_G            47           rom.psm
 ASCII_H            48           rom.psm
 ASCII_I            49           rom.psm
 ASCII_J            4A           rom.psm
 ASCII_K            4B           rom.psm
 ASCII_L            4C           rom.psm
 ASCII_M            4D           rom.psm
 ASCII_N            4E           rom.psm
 ASCII_O            4F           rom.psm
 ASCII_P            50           rom.psm
 ASCII_Q            51           rom.psm
 ASCII_R            52           rom.psm
 ASCII_S            53           rom.psm
 ASCII_T            54           rom.psm
 ASCII_U            55           rom.psm
 ASCII_V            56           rom.psm
 ASCII_W            57           rom.psm
 ASCII_X            58           rom.psm
 ASCII_Y            59           rom.psm
 ASCII_Z            5A           rom.psm
 RX_STORE_CNT       10           rom.psm
 RX_STORE_BASE      11           rom.psm
 DMA_STR_BASE       1A           rom.psm



No TABLEs defined



List of text strings

 STRING name       String              Source PSM File

 KCPSM6_version$   "v2.70"             
 datestamp$        "13 Nov 2020"       
 timestamp$        "10:37:07"          
 HEXAVAL$          "0123456789ABCDEF"  rom.psm
 SAYHELLOW$        "Hello World!"      rom.psm
 MERCADONA$        "Quiere bolsa?"     rom.psm



List of line labels

   Label              Addr  Source PSM File

 * start              000   rom.psm
   loop               00A   rom.psm
 * DMA_TX_TEST        00B   rom.psm
 * RX_TEST            00F   rom.psm
 * DEFAULT_TEST       04F   rom.psm
   DELAY_MS           076   rom.psm
   DELAY_1MS          07A   rom.psm
   DELAY_1MS_LOOP     07C   rom.psm
   DMA_CH1_CALLBACK   081   rom.psm
   DMA_CH2_CALLBACK   082   rom.psm
   DMA_CH3_CALLBACK   083   rom.psm
   GPIOA_CALLBACK     084   rom.psm
 * GPIOB_CALLBACK     085   rom.psm
   TX_CALLBACK        086   rom.psm
   RX_CALLBACK        A80   rom.psm
   RX_INBOUND         A8B   rom.psm
   NEW_COMMAND        B80   rom.psm
   GPIO_CMD           B89   rom.psm
   GPIO_GET_PIN       B91   rom.psm
   GPIO_CALC_MASK     B9B   rom.psm
   GPIO_MASK_LOOP     BA2   rom.psm
   GPIO_CMD_SELECT    BA9   rom.psm
   GPIO_CONF_CMD      BB3   rom.psm
   GPIO_SET_CMD       BB7   rom.psm
   GPIO_RESET_CMD     BBB   rom.psm
   TEMP_CMD           BC0   rom.psm
   REG_CMD            BC1   rom.psm
   CLC_CMD            BC2   rom.psm
   LOOP_CMD_CLC       BC5   rom.psm
 * hellow             BCB   rom.psm
   cajero             BD8   rom.psm
   hexv               BE6   rom.psm
   DMA_TX_STR         BF7   rom.psm
   DMA_TX_STR_LOOP    BF9   rom.psm
   DMA_TX_LOAD        C03   rom.psm
 * HEX2DEC            C11   rom.psm
   HEXCMP             C14   rom.psm
   HEXVAL_RETURN      C1D   rom.psm
   DEC2HEX            C1E   rom.psm
   DEC2HEX_C          C23   rom.psm
 * ISR                F80   rom.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             85
 STAR              -

 AND               3
 OR                3
 XOR               1

 ADD              17
 ADDCY             4
 SUB               6
 SUBCY             -

 TEST              7
 TESTCY            -
 COMPARE          17
 COMPARECY         -

 SL0               -
 SL1               -
 SLX               -
 SLA               -
 RL                3
 SR0               -
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT            14
 OUTPUT           63
 OUTPUTK           -

 STORE             -
 FETCH             -

 DISABLE           1
 ENABLE            3
 RETURNI           1

 JUMP             33
 JUMP@             -
 CALL              9
 CALL@             3
 RETURN           17
 LOAD&RETURN      44

 HWBUILD           -



End of KCPSM6 log file.
